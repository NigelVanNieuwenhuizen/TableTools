{
    "create_directory": {
        "name": "create_directory",
        "category": "TableTools",
        "signature": "(self, dir_name)",
        "doc": "Attempt to create a directory ('dir_name').\n\nParameters:\n\ndir_name (string): the name of the directory to create. No directory will be created if a folder with this name already exists in this location.",
        "example": "tt.create_directory(dir_name)"
    },
    "delete_directory": {
        "name": "delete_directory",
        "category": "TableTools",
        "signature": "(self, path)",
        "doc": "Attempt to delete a directory ('path') and all its contents. Directory and contents are NOT sent to the recycle bin and cannot be recovered once deleted.\n\nParameters:\n\npath (string): the name of the directory to delete for, including the path and extension.",
        "example": "tt.delete_directory(path)"
    },
    "delete_file": {
        "name": "delete_file",
        "category": "TableTools",
        "signature": "(self, filename)",
        "doc": "Attempt to delete a file ('filename'). Files are NOT sent to the recycle bin and cannot be recovered once deleted.\n\nParameters:\n\nfilename (string): the name of the file to delete, including the path and extension.",
        "example": "tt.delete_file(filename)"
    },
    "dict_to_table": {
        "name": "dict_to_table",
        "category": "TableTools",
        "signature": "(self, dict)",
        "doc": "Attempt to convert a Python dictionary object ('dict') into a Table object and return a new Table.\n\nParameters:\n\ndict (dictionary): the dictionary to be converted to a Table object. The dictionary keys will be used as column headers, and the dictionary values should be equal-length arrays of values representing column data.",
        "example": "result = tt.dict_to_table(dict)"
    },
    "directory_exists": {
        "name": "directory_exists",
        "category": "TableTools",
        "signature": "(self, path)",
        "doc": "Determine if a directory ('path') exists. Returns True or False.\n\nParameters:\n\npath (string): the name of the directory to check for.",
        "example": "result = tt.directory_exists(path)"
    },
    "display_object_functions": {
        "name": "display_object_functions",
        "category": "Table",
        "signature": "(self)",
        "doc": "Print a list of all Table object functions.",
        "example": "table.display_object_functions()"
    },
    "display_processing_time": {
        "name": "display_processing_time",
        "category": "TableTools",
        "signature": "(self, decimals=2)",
        "doc": "Compute and print the processing time of a block of code. A timer must have been previously initialized.\n\nParameters: \n\ndecimals (integer): the number of decimals places the processing time will be rounded to.",
        "example": "tt.display_processing_time(decimals=2)"
    },
    "display_toolboxes": {
        "name": "display_toolboxes",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Print a list of all toolboxes accessed by the TableTools object, along with a general description of toolbox functionality.",
        "example": "tt.display_toolboxes()"
    },
    "display_total_functions": {
        "name": "display_total_functions",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Print the total number of functions in the TableTools object, the Table class, and all toolboxes.",
        "example": "tt.display_total_functions()"
    },
    "file_exists": {
        "name": "file_exists",
        "category": "TableTools",
        "signature": "(self, filename)",
        "doc": "Determine if a file ('filename') exists. Returns True or False.\n\nParameters:\n\nfilename (string): the name of the file to check for, including the path and extension.",
        "example": "result = tt.file_exists(filename)"
    },
    "get_boolean_values": {
        "name": "get_boolean_values",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Get the current string values that TableTools interprets as Boolean True or False. Returns a list of [boolean_true_values, boolean_false_values].",
        "example": "result = tt.get_boolean_values()"
    },
    "get_file_size_in_input_dir": {
        "name": "get_file_size_in_input_dir",
        "category": "TableTools",
        "signature": "(self, file_ext='', include='', exclude='', fmt='kb')",
        "doc": "Return a list of the sizes of files in the input directory.\n\nParameters:\n\nfile_ext (string, list): the extension of the file type to determine size of, or a list of extensions to determine size of. May be left blank to include all file extensions.\n\ninclude (string, list): a character, subtring, or list of characters and/or substrings that must be included in the file name for the file size to be determined. May be left blank to leave files unfiltered.\n\nexclude (string, list): a character, subtring, or list of characters and/or substrings that must not be in the file name for the file size to be determined. May be left blank to leave files unfiltered.\n\nfmt (string): the format of the file sizes to be returned. May be specified as \"b\" for bytes, \"kb\" for kilobytes, \"mb\" for megabytes, or \"gb\" for gigabytes.",
        "example": "result = tt.get_file_size_in_input_dir(file_ext='', include='', exclude='', fmt='kb')"
    },
    "get_files_in_input_dir": {
        "name": "get_files_in_input_dir",
        "category": "TableTools",
        "signature": "(self, file_ext='', include='', exclude='')",
        "doc": "Return a list of files in the input directory.\n\nParameters:\n\nfile_ext (string, list): the extension of the file type to be returned, or a list of extensions to be returned. May be left blank to include all file extensions.\n\ninclude (string, list): a character, subtring, or list of characters and/or substrings that must be included in the file name for the file to be returned. May be left blank to leave files unfiltered.\n\nexclude (string, list): a character, subtring, or list of characters and/or substrings that must not be in the file name for the file to be returned. May be left blank to leave files unfiltered.",
        "example": "result = tt.get_files_in_input_dir(file_ext='', include='', exclude='')"
    },
    "get_in_dir": {
        "name": "get_in_dir",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Return the input directory if an input directory has been set.",
        "example": "result = tt.get_in_dir()"
    },
    "get_out_dir": {
        "name": "get_out_dir",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Return the output directory if an output directory has been set.",
        "example": "result = tt.get_out_dir()"
    },
    "get_overwrite_state": {
        "name": "get_overwrite_state",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Return the state for allowing TableTools to overwrite files when writing.",
        "example": "result = tt.get_overwrite_state()"
    },
    "help": {
        "name": "help",
        "category": "TableTools",
        "signature": "(self, topic=None)",
        "doc": "Display the help entry for a given topic. The topic may refer to any function belonging to the TableTools object, a Table object, or any toolbox. If no topic is provided, a list of all available help topics will be printed.\n\nParameters:\n\ntopic (string): the name of the function or toolbox to display help for. Do not include function parentheses.",
        "example": "tt.help(topic=None)"
    },
    "initialize_progress_counter": {
        "name": "initialize_progress_counter",
        "category": "TableTools",
        "signature": "(self, total)",
        "doc": "Initialize a progress counter to provide updates (percent complete) on the progress of iterative processing.\n\nParameters:\n\ntotal (integer): the total number of iterations to provide progress updates for.",
        "example": "tt.initialize_progress_counter(total)"
    },
    "initialize_timer": {
        "name": "initialize_timer",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Initialize a timer to measure the processing time of a block of code. Returns start time for convenience.",
        "example": "result = tt.initialize_timer()"
    },
    "load_example_data": {
        "name": "load_example_data",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Load an example dataset for experimentation and demonstration purposes and return a new Table object.",
        "example": "result = tt.load_example_data()"
    },
    "new_table": {
        "name": "new_table",
        "category": "TableTools",
        "signature": "(self, data=None)",
        "doc": "Create a new Table object to hold tabular data. May be created empty or initialized with an existing Table object ('data').\n\nParameters:\n\ndata (object): the Table object to copy data from. May be left blank to create an empty Table object.",
        "example": "result = tt.new_table(data=None)"
    },
    "num_files_in_input_dir": {
        "name": "num_files_in_input_dir",
        "category": "TableTools",
        "signature": "(self, file_ext='', include='', exclude='')",
        "doc": "Return the number of files in the input directory.\n\nParameters:\n\nfile_ext (string, list): the extension of the file type to be counted. May be left blank to include all file extensions.\n\ninclude (string, list): a character, subtring, or list of characters and/or substrings that must be included in the file name for the file to be counted. May be left blank to leave files unfiltered..\n\nexclude (string, list): a character, subtring, or list of characters and/or substrings that must not be in the file name for the file to be counted. May be left blank to leave files unfiltered..",
        "example": "result = tt.num_files_in_input_dir(file_ext='', include='', exclude='')"
    },
    "open_file": {
        "name": "open_file",
        "category": "TableTools",
        "signature": "(self, filename='')",
        "doc": "Open a file ('filename') with the default program specified by the operating system.\n\nParameters:\n\nfilename (string): the name of the file to be opened, including the path and extension.",
        "example": "tt.open_file(filename='')"
    },
    "peek_raw_text": {
        "name": "peek_raw_text",
        "category": "TableTools",
        "signature": "(self, text_file, extension='.txt', num_lines=5, return_lines=False)",
        "doc": "Attempt to read a raw text file ('text_file') and print or return the specified number of lines ('num_lines'). No data type conversion is performed and data is not returned in a Table object. This function streams the file line by line and stops after 'num_lines', so very large files can be inspected safely without loading the entire file into memory.\n\nParameters:\n\ntext_file (string): the name of the text file to be read, including the \".txt\" extension.\n\nextension (string): the extension of the file to be read.\n\nnum_lines (integer): the number of lines to be printed or returned.\n\nreturn_lines (Boolean): flag to indicate if num_lines will be printed to the terminal (False) or returned as a list (True).",
        "example": "result = tt.peek_raw_text(text_file, extension='.txt', num_lines=5, return_lines=False)"
    },
    "read_csv": {
        "name": "read_csv",
        "category": "TableTools",
        "signature": "(self, csv_file, skiprows=0, headers=True)",
        "doc": "Attempt to read a delimited CSV file ('csv_file') and store the data in a new Table object.\n\nParameters:\n\ncsv_file (string): the name of the CSV file to be read, including the \".csv\" extension.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_csv(csv_file, skiprows=0, headers=True)"
    },
    "read_dbf": {
        "name": "read_dbf",
        "category": "TableTools",
        "signature": "(self, dbf_file)",
        "doc": "Attempt to read a Dbase or Xbase database file ('dbf_file') with a \".dbf\" extension and store the data in a Table object. Null values in the file will be read as empty strings ('').\n\nParameters:\n    \ndbf_file (string): the name of the Dbase or Xbase file to be read, including the \".dbf\" extension.",
        "example": "result = tt.read_dbf(dbf_file)"
    },
    "read_fixedwidth": {
        "name": "read_fixedwidth",
        "category": "TableTools",
        "signature": "(self, fw_file, extension='.txt', widths=None, skiprows=0, headers=True, overflow=None)",
        "doc": "Attempt to read a fixed-width text file ('txt_file') and store the data in a new Table object.\n\nParameters:\n\nfw_file (string): the name of the fixed-width file to be read, including the extension.\n\nextension (string): the extension of the file to be read.\n\nwidths (list): a list of character widths of each column. If None, column boundaries will be auto-detected based on whitespace patterns.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.\n\noverflow (string): how column overflow should be managed if a column value exceeds its specified width. If None, columns are silently truncationed. If \"auto-expand\", columns are expanded as need to fit values. If \"strict\", an error is raised.",
        "example": "result = tt.read_fixedwidth(fw_file, extension='.txt', widths=None, skiprows=0, headers=True, overflow=None)"
    },
    "read_html": {
        "name": "read_html",
        "category": "TableTools",
        "signature": "(self, html_file, headers=True, table_index=0)",
        "doc": "Attempt to read a table in an HTML document ('html_file') and store the data in a new Table object.\n\nParameters:\n\nhtml_file (string): the name of the HTML file to be read, including the \".html\" extension.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.\n\ntable_index (integer): which table to read. In an HTML document with one table, index must be 0 (first table). In a document with multiple tables, other index values may be used to read other tables.",
        "example": "result = tt.read_html(html_file, headers=True, table_index=0)"
    },
    "read_ini": {
        "name": "read_ini",
        "category": "TableTools",
        "signature": "(self, ini_file, headers=True, skiprows=0)",
        "doc": "Attempt to read an INI-style configuration file ('ini_file') and store the data in a new Table object. Each section becomes a row, and keys within sections become columns. Missing keys are filled with None.\n\nParameters:\n\nini_file (string): the name of the INI file to be read. If no file extension is provided, '.ini' will be appended automatically.\n\nheaders (Boolean): flag to indicate if the keys should be used as column headers. If False, generic headers will be automatically generated.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.",
        "example": "result = tt.read_ini(ini_file, headers=True, skiprows=0)"
    },
    "read_json": {
        "name": "read_json",
        "category": "TableTools",
        "signature": "(self, json_file)",
        "doc": "Attempt to read a JSON file ('json_file') and store the data in a new Table object. It is expected that the JSON file has a single object. The object's keys will be used as column headers, and the object's values should be equal-length arrays representing the column data.\n\nParameters:\n\njson_file (string): the name of the JSON file to be read, including the \".json\" extension.",
        "example": "result = tt.read_json(json_file)"
    },
    "read_latex": {
        "name": "read_latex",
        "category": "TableTools",
        "signature": "(self, tex_file, headers=True, skiprows=0, table_index=0)",
        "doc": "Attempt to read a table in a LaTeX document ('tex_file') and store the data in a new Table object.\n\nParameters:\n\ntex_file (string): the name of the LaTeX file to be read, including the \".tex\" extension.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\ntable_index (integer): which table to read. LaTeX documents may contain multiple tables. Index 0 refers to the first table found.",
        "example": "result = tt.read_latex(tex_file, headers=True, skiprows=0, table_index=0)"
    },
    "read_markdown": {
        "name": "read_markdown",
        "category": "TableTools",
        "signature": "(self, md_file, headers=True, skiprows=0, table_index=0)",
        "doc": "Attempt to read a table in a Markdown document ('md_file') and store the data in a new Table object.\n\nParameters:\n\nmd_file (string): the name of the Markdown file to be read, including the \".md\" extension.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\ntable_index (integer): which table to read. Markdown documents may contain multiple tables. Index 0 refers to the first table found.",
        "example": "result = tt.read_markdown(md_file, headers=True, skiprows=0, table_index=0)"
    },
    "read_other_text": {
        "name": "read_other_text",
        "category": "TableTools",
        "signature": "(self, text_file, extension, delimiter=',', skiprows=0, headers=True)",
        "doc": "Attempt to read a delimited text file ('text_file') with an extension other than \".txt\" and store the data in a new Table object.\n\nParameters:\n\ntext_file (string): the name of the text file to be read.\n\nextension (string): the extension of the file to be read.\n\ndelimiter (string): the character that separates values in the text file. A comma is the default delimiter.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_other_text(text_file, extension, delimiter=',', skiprows=0, headers=True)"
    },
    "read_psv": {
        "name": "read_psv",
        "category": "TableTools",
        "signature": "(self, psv_file, skiprows=0, headers=True)",
        "doc": "Attempt to read a pipe-separated values file ('psv_file') and store the data in a new Table object.\n\nParameters:\n\npsv_file (string): the name of the PSV file to be read, including the \".psv\" extension.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_psv(psv_file, skiprows=0, headers=True)"
    },
    "read_r_dput": {
        "name": "read_r_dput",
        "category": "TableTools",
        "signature": "(self, r_file, headers=True, skiprows=0)",
        "doc": "Attempt to read an R dput() representation of a data frame ('r_file') and store the data in a new Table object.\n\nThe R object must be of the form:\n    structure(list(\n        col1 = c(...),\n        col2 = c(...),\n        ...\n    ))\n\nParameters:\n\nr_file (string): the name of the R dput file to be read. If no file extension is provided, '.r' will be appended automatically.\n\nheaders (Boolean): flag to indicate if the column names should be used as headers. If False, generic headers will be automatically generated.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.",
        "example": "result = tt.read_r_dput(r_file, headers=True, skiprows=0)"
    },
    "read_raw_text": {
        "name": "read_raw_text",
        "category": "TableTools",
        "signature": "(self, text_file, extension='.txt')",
        "doc": "Attempt to read a raw text file ('text_file') and return the contents as a nested list. No data type conversion is performed and data is not returned in a Table object.\n\nParameters:\n\ntext_file (string): the name of the text file to be read, including the \".txt\" extension.\n\nextension (string): the extension of the file to be read.",
        "example": "result = tt.read_raw_text(text_file, extension='.txt')"
    },
    "read_sql": {
        "name": "read_sql",
        "category": "TableTools",
        "signature": "(self, sql_file, table_name)",
        "doc": "Attempt to read a table ('table_name') from the specified SQL database ('sql_file') and store the data in a new Table object.\n\nParameters:\n\nsql_file (string): the name of the SQL database file to be read, including one of \".db\", \".db2\", \".db3\", \".sqlite\", \".sqlite2\", or \".sqlite3\" as an extension. If no extension is provided, the function will attempt to open a file with the \".sqlite\" extension.\n\ntable_name (string): the name of the table to be read from the specified database file. ",
        "example": "result = tt.read_sql(sql_file, table_name)"
    },
    "read_text": {
        "name": "read_text",
        "category": "TableTools",
        "signature": "(self, text_file, delimiter=',', skiprows=0, headers=True)",
        "doc": "Attempt to read a delimited text file ('text_file') with a \".txt\" extension and store the data in a new Table object.\n\nParameters:\n\ntext_file (string): the name of the text file to be read, including the \".txt\" extension.\n\ndelimiter (string): the character that separates values in the text file. A comma is the default delimiter.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_text(text_file, delimiter=',', skiprows=0, headers=True)"
    },
    "read_tsv": {
        "name": "read_tsv",
        "category": "TableTools",
        "signature": "(self, tsv_file, skiprows=0, headers=True)",
        "doc": "Attempt to read a tab-separated values file ('tsv_file') and store the data in a new Table object.\n\nParameters:\n\ntsv_file (string): the name of the TSV file to be read, including the \".tsv\" extension.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_tsv(tsv_file, skiprows=0, headers=True)"
    },
    "read_xlsx": {
        "name": "read_xlsx",
        "category": "TableTools",
        "signature": "(self, xlsx_file, sheet_name, headers=True)",
        "doc": "Attempt to read a sheet ('sheet_name') from the specified Excel workbook ('xlsx_file') and store the data in a new Table object.\n\nParameters:\n\nxlsx_file (string): the name of the Excel workbook file to be read, including the \".xlsx\" extension.\n\nsheet_name (string): the name of the sheet to be read from the specified workbook file.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.",
        "example": "result = tt.read_xlsx(xlsx_file, sheet_name, headers=True)"
    },
    "read_xml": {
        "name": "read_xml",
        "category": "TableTools",
        "signature": "(self, xml_file, headers=True, skiprows=0, table_index=0)",
        "doc": "Attempt to read a table in an XML document ('xml_file') and store the data in a new Table object.\n\nParameters:\n\nxml_file (string): the name of the XML file to be read, including the \".xml\" extension.\n\nheaders (Boolean): flag to indicate if the columns have headers. If columns do not have headers, generic headers will be automatically generated.\n\nskiprows (integer): the number of rows to skip at the start of the file, if necessary.\n\ntable_index (integer): which table to read. XML documents may contain multiple <table> elements. Index 0 refers to the first table found.",
        "example": "result = tt.read_xml(xml_file, headers=True, skiprows=0, table_index=0)"
    },
    "read_yaml": {
        "name": "read_yaml",
        "category": "TableTools",
        "signature": "(self, yaml_file)",
        "doc": "Attempt to read a YAML document ('yaml_file') containing a list of dictionaries and store the data in a new Table object.\n\nThe YAML file must contain a top-level list, where each element is a dictionary representing a row. Dictionary keys become column headers.\n\nParameters:\n\nyaml_file (string): the name of the YAML file to be read, including the \".yaml\" or \".yml\" extension.",
        "example": "result = tt.read_yaml(yaml_file)"
    },
    "return_processing_time": {
        "name": "return_processing_time",
        "category": "TableTools",
        "signature": "(self, decimals=2)",
        "doc": "Compute the processing time of a block of code. A timer must have been previously initialized. Returns a tuple of (processing time, units).\n\nParameters: \n\ndecimals (integer): the number of decimals places the processing time will be rounded to.",
        "example": "result = tt.return_processing_time(decimals=2)"
    },
    "set_boolean_values": {
        "name": "set_boolean_values",
        "category": "TableTools",
        "signature": "(self, true_values=['true', 't', 'yes'], false_values=['false', 'f', 'no'])",
        "doc": "Set the string values that TableTools will interpret as Boolean True or False. Values are case-insensitive.\n\nParameters:\n\ntrue_values (list): list of strings to interpret as Boolean True.\n\nfalse_values (list): list of strings to interpret as Boolean False.",
        "example": "tt.set_boolean_values(true_values=['true', 't', 'yes'], false_values=['false', 'f', 'no'])"
    },
    "set_in_dir": {
        "name": "set_in_dir",
        "category": "TableTools",
        "signature": "(self, path)",
        "doc": "Set an input directory ('path') to read files from. Setting an input directory is not required when reading files, however, if an input directory has not been set a path must be specified along with the filename when reading files.\n\nParameters:\n\npath (string): the path of the input directory.",
        "example": "tt.set_in_dir(path)"
    },
    "set_out_dir": {
        "name": "set_out_dir",
        "category": "TableTools",
        "signature": "(self, path)",
        "doc": "Set an output directory ('path') to write files to. Setting an output directory is not required when writing files, however, if an output directory has not been set a path must be specified along with the filename when writing files.\n\nParameters:\n\npath (string): the path of the output directory.",
        "example": "tt.set_out_dir(path)"
    },
    "set_overwrite_state": {
        "name": "set_overwrite_state",
        "category": "TableTools",
        "signature": "(self, state)",
        "doc": "Set the state for allowing TableTools to overwrite files when writing.\n\nParameters:\n\nstate (Boolean): flag to indicate if file overwrite is enabled.",
        "example": "tt.set_overwrite_state(state)"
    },
    "table_to_dict": {
        "name": "table_to_dict",
        "category": "TableTools",
        "signature": "(self, table)",
        "doc": "Attempt to convert a Table object ('table') to a Python dictionary object.\n\nParameters:\n\ntable (object): the Table object to be converted to a Python dictionary. The Table column headers will be used as dictionary keys, and the Table columns will be arrays of values.",
        "example": "result = tt.table_to_dict(table)"
    },
    "update_progress": {
        "name": "update_progress",
        "category": "TableTools",
        "signature": "(self, display='percent', timing=None, decimals=2)",
        "doc": "Update an initialized progress counter and print the percent completion of an iterative process. Must be called within the iteration loop.\n\nParameters:\n\ndisplay (string): the format of the progress output. May be specified as \"percent\" to print the percent completion, \"total\" to print the iteration count, or \"total_percent\" to print both count and percent.\n\ntiming (string): optional timing information to include. May be specified as \"elapsed\", \"rate\", \"eta\", \"elapsed_rate\", \"elapsed_eta\", \"rate_eta\", or \"elapsed_rate_eta\".\n\ndecimals (integer): the number of decimals places the processing time will be rounded to.",
        "example": "tt.update_progress(display='percent', timing=None, decimals=2)"
    },
    "update_progress_bar": {
        "name": "update_progress_bar",
        "category": "TableTools",
        "signature": "(self, display='bar', length=50, timing=None, decimals=2)",
        "doc": "Update an initialized progress counter and print a progress bar displaying completion of an iterative process. Must be called within the iteration loop.\n\nParameters:\n\ndisplay (string): the format of the progress output. May be specified as \"bar\" to print only the progress bar, \"percent\" to print the progress bar with percent completion, \"total\" to print the progress bar with the iteration count, or \"total_percent\" to print the progress bar with both count and percent.\n\nlength (integer): the length of the progress bar in characters. Should be between 5 and 100 characters.\n\ntiming (string): optional timing information to include. May be specified as \"elapsed\", \"rate\", \"eta\", \"elapsed_rate\", \"elapsed_eta\", \"rate_eta\", or \"elapsed_rate_eta\".\n\ndecimals (integer): the number of decimals places the processing time will be rounded to.",
        "example": "tt.update_progress_bar(display='bar', length=50, timing=None, decimals=2)"
    },
    "version": {
        "name": "version",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Print the current version of TableTools.",
        "example": "tt.version()"
    },
    "view_manual": {
        "name": "view_manual",
        "category": "TableTools",
        "signature": "(self)",
        "doc": "Open a web browser to view the TableTools manual.",
        "example": "tt.view_manual()"
    },
    "write_csv": {
        "name": "write_csv",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a CSV file ('filename') with a \".csv\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_csv(table, filename)"
    },
    "write_dbf": {
        "name": "write_dbf",
        "category": "TableTools",
        "signature": "(self, table, filename, csize, cdeci)",
        "doc": "Attempt to write the data stored in a Table object to a Dbase/Xbase file ('filename') with a \".dbf\" extension. Headers should not be longer than 10 characters. Headers longer than 10 characters will be reduced to 10 characters. Empty strings '' will be considered Null values.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written. Leave this parameter blank to overwrite the original file, if specified.\n\ncsize (list): a list of the sizes (the maximum length of values) of each column, in the order the columns appear in the data.\n\ncdeci (list): a list of the number of decimal places of each column, in the order the columns appear in the data. Columns of float values should have a value greater than 0 to indicate the number of decimals. All other columns should be given a value of 0.",
        "example": "tt.write_dbf(table, filename, csize, cdeci)"
    },
    "write_fixedwidth": {
        "name": "write_fixedwidth",
        "category": "TableTools",
        "signature": "(self, table, filename, extension='.txt', widths=None, overflow=None)",
        "doc": "Attempt to write the data stored in a Table object to a fixed-width text file ('filename') with a \".txt\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.\n\nextension (string): the extension of the file to be read.\n\nwidths (list): a list of character widths of each column. If None, widths will be auto-detected from the data.\n\noverflow (string): how column overflow should be managed if a value exceeds its specified width. If None, values are silently truncated. If \"auto-expand\", columns are expanded as needed to fit values. If \"strict\", an error is raised.",
        "example": "tt.write_fixedwidth(table, filename, extension='.txt', widths=None, overflow=None)"
    },
    "write_html": {
        "name": "write_html",
        "category": "TableTools",
        "signature": "(self, table, filename, style='standard')",
        "doc": "Attempt to write the data stored in a Table object to a table in an HTML file ('filename') with the \".html\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.\n\nstyle (string): the style of the output table. The style may be specified as \"standard\" to enclose all cells in horizontal and vertical borders, or \"scientific\" to remove vertical borders from cells.",
        "example": "tt.write_html(table, filename, style='standard')"
    },
    "write_ini": {
        "name": "write_ini",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to an INI-style configuration file ('filename') with a \".ini\" extension. Each row in the Table becomes a section, and each column becomes a key-value pair within that section.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_ini(table, filename)"
    },
    "write_json": {
        "name": "write_json",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a JSON file ('filename') with a \".json\" extension. This JSON file will have a single object. The object's keys will be the Table column headers, and the object's values will be arrays of column values.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_json(table, filename)"
    },
    "write_latex": {
        "name": "write_latex",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a LaTeX file ('filename') with a \".tex\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_latex(table, filename)"
    },
    "write_markdown": {
        "name": "write_markdown",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a Markdown file ('filename') with a \".md\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_markdown(table, filename)"
    },
    "write_other_text": {
        "name": "write_other_text",
        "category": "TableTools",
        "signature": "(self, table, filename, extension, delimiter=',')",
        "doc": "Attempt to write the data stored in a Table object to a text file ('filename') with an extension other than \".txt\".\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.\n\ndelimiter (string): the character that separates values in the output file. A comma is the default delimiter.\n\nextension (string): the extension of the file to be written.",
        "example": "tt.write_other_text(table, filename, extension, delimiter=',')"
    },
    "write_psv": {
        "name": "write_psv",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a PSV file ('filename') with a \".psv\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_psv(table, filename)"
    },
    "write_r_dput": {
        "name": "write_r_dput",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to an R dput() representation of a data frame ('filename') with a \".r\" extension. The output will be a structure(list(...)) object where each column is represented as a named vector using R's c(...) syntax.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "result = tt.write_r_dput(table, filename)"
    },
    "write_sql": {
        "name": "write_sql",
        "category": "TableTools",
        "signature": "(self, table, filename, table_name)",
        "doc": "Attempt to write the data stored in a Table object to a table in a new SQL database file ('filename'), or add a new table to an existing SQL database file. Data headers should not have spaces. Spaces in the data headers may be corrected with the remove_header_space function in the Table object.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the database file to be written. If the specified filename points to an existing SQL database file, the function will attempt to write the data to the existing database file as a new table. Possible database file extensions include \".db\", \".db2\", \".db3\", \".sqlite\", \".sqlite2\", and \".sqlite3\", but if a database extension is not included in the file name, the file will be written as a \".sqlite\" file.\n\ntable_name (string): the name of the table to be written to the database file. The table name may have underscores but should not have spaces. If the table name already exists in the database, the table will be overwritten, but other tables in the database will remain intact.",
        "example": "tt.write_sql(table, filename, table_name)"
    },
    "write_text": {
        "name": "write_text",
        "category": "TableTools",
        "signature": "(self, table, filename, delimiter=',')",
        "doc": "Attempt to write the data stored in a Table object to a text file ('filename') with a \".txt\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.\n\ndelimiter (string): the character that separates values in the output file. A comma is the default delimiter.",
        "example": "tt.write_text(table, filename, delimiter=',')"
    },
    "write_tsv": {
        "name": "write_tsv",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a TSV file ('filename') with a \".tsv\" extension.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_tsv(table, filename)"
    },
    "write_xml": {
        "name": "write_xml",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to an XML file ('filename') with a \".xml\" extension. The XML document will contain a single <table> element, with each row represented as a <row> element containing child tags corresponding to column headers.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_xml(table, filename)"
    },
    "write_yaml": {
        "name": "write_yaml",
        "category": "TableTools",
        "signature": "(self, table, filename)",
        "doc": "Attempt to write the data stored in a Table object to a YAML file ('filename') with a \".yaml\" extension. The YAML document will contain a top-level list of dictionaries, where each dictionary represents a row and keys correspond to column headers.\n\nParameters:\n\ntable (object): the Table object to be written.\n\nfilename (string): the name of the file to be written.",
        "example": "tt.write_yaml(table, filename)"
    },
    "append_column": {
        "name": "append_column",
        "category": "Table",
        "signature": "(self, vals, col_header)",
        "doc": "Append a new column of values ('vals') to the end of the data. This function can also be used to add a first column of data to a new Table object.\n\nParameters:\n\nvals (list): the column of values to be appended.\n\ncol_header (string): the header of the column to be appended.",
        "example": "table.append_column(vals, col_header)"
    },
    "append_columns": {
        "name": "append_columns",
        "category": "Table",
        "signature": "(self, vals, col_headers)",
        "doc": "Append a new column of values ('vals') to the end of the data. This function can also be used to add a first column of data to a new Table object.\n\nParameters:\n\nvals (list): a nested list of column values to be appended.\n\ncol_headers (list): a list of headers of the columns to be appended.",
        "example": "table.append_columns(vals, col_headers)"
    },
    "append_row": {
        "name": "append_row",
        "category": "Table",
        "signature": "(self, vals)",
        "doc": "Append a new row of values ('vals') to the end of the data. Can be used to add a first row to an empty Table.\n\nParameters:\n\nvals (list): the row of values to be appended. If the Table is not empty, the new row must be the same length as the number columns.",
        "example": "table.append_row(vals)"
    },
    "append_rows": {
        "name": "append_rows",
        "category": "Table",
        "signature": "(self, vals)",
        "doc": "Append a list of rows ('vals') to the end of the data.\n\nParameters:\n\nvals (list): the list of rows to be appended. If the Table is not empty, each row must be the same length as the number columns.",
        "example": "table.append_rows(vals)"
    },
    "append_table_columns": {
        "name": "append_table_columns",
        "category": "Table",
        "signature": "(self, table)",
        "doc": "Append the columns of another Table object ('Table') to the end of this Table. Tables must have the same number of rows.\n\nParameters:\n\ntable (object): the Table object to append columns from.",
        "example": "table.append_table_columns(table)"
    },
    "append_table_rows": {
        "name": "append_table_rows",
        "category": "Table",
        "signature": "(self, table)",
        "doc": "Append the rows of another Table object ('Table') to the end of this Table. Tables must have the same number of columns. It is assumed column data types are the same between Tables.\n\nParameters:\n\ntable (object): the Table object to append rows from.",
        "example": "table.append_table_rows(table)"
    },
    "apply_column": {
        "name": "apply_column",
        "category": "Table",
        "signature": "(self, column, func, args=None, kwargs=None, new_header=None, return_result=False)",
        "doc": "Apply a user-defined function element-wise to a column ('column'). The function ('func') is applied to each value in the specified column. The result can be returned directly as a list, used to overwrite the existing column, or appended as a new column.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nfunc (callable): the function that accepts a single value and returns a transformed value. The function is applied element-wise.\n\nargs (tuple): the tuple of additional positional arguments to pass to the user-defined function. No lambda expressions are required.\n\nkwargs (dict): the dictionary of additional keyword arguments to pass to the user-defined function. No lambda expressions are required.\n\nnew_header (string, optional): if provided and return_result is False, the transformed values will be appended as a new column with this header.\n\nreturn_result (bool): if True, the transformed list is returned and the table is not modified.",
        "example": "table.apply_column(column, func, args=None, kwargs=None, new_header=None, return_result=False)"
    },
    "apply_row": {
        "name": "apply_row",
        "category": "Table",
        "signature": "(self, row, func, args=None, kwargs=None, append_row=False, return_result=False)",
        "doc": "Apply a user-defined function element-wise to a row ('row'). The function ('func') is applied to each value in the specified row. The result can be returned directly as a list, used to overwrite the existing row, or appended as a new row.\n\nParameters:\n\nrow (integer): the index of the row the operation will be performed on.\n\nfunc (callable): the function that accepts a single value and returns a transformed value. The function is applied element-wise.\n\nargs (tuple): the tuple of additional positional arguments to pass to the user-defined function. No lambda expressions are required.\n\nkwargs (dict): the dictionary of additional keyword arguments to pass to the user-defined function. No lambda expressions are required.\n\nappend_row (bool): if True and return_result is False, the transformed row will be appended as a new row at the end of the table. If False and return_result is False, the transformed row will overwrite the existing row at 'row_index'.",
        "example": "table.apply_row(row, func, args=None, kwargs=None, append_row=False, return_result=False)"
    },
    "autogenerate_headers": {
        "name": "autogenerate_headers",
        "category": "Table",
        "signature": "(self)",
        "doc": "Autogenerate generic headers for the data if there are no column headers.",
        "example": "table.autogenerate_headers()"
    },
    "bar_chart": {
        "name": "bar_chart",
        "category": "Table",
        "signature": "(self, column, title='Bar Chart', x_label='Category', y_label='Count', num_ticks=6, colour='#4e79a7', margin=60, filename='bar_chart.html', open_browser=False)",
        "doc": "Create a bar chart from a column of categorical values ('column') and configure chart elements.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be visualized. \n\ntitle (string): the title of the bar chart.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_ticks (integer): The number of tick marks to draw on the y axis.\n\ncolour (string): the colour of the bars. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.bar_chart(column, title='Bar Chart', x_label='Category', y_label='Count', num_ticks=6, colour='#4e79a7', margin=60, filename='bar_chart.html', open_browser=False)"
    },
    "box_plot": {
        "name": "box_plot",
        "category": "Table",
        "signature": "(self, category_cols, labels=None, title='Box Plot', x_label='Categories', y_label='Values', num_ticks=5, colour='#4e79a7', margin=60, filename='box_plot.html', open_browser=False)",
        "doc": "Create a box plot from a list of columns ('category_cols') and configure plot elements. One box will be created per column.\n\nParameters:\n\ncategory_cols (list): the nested list of column indices or headers of each category to be visualized.\n\nlabels (list): the list of category labels for the x axis. Must be the same length as category_cols.\n\ntitle (string): the title of the box plot.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_ticks (integer): the number of tick marks to draw on the y axis.\n\ncolour (string): the colour of the boxes. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.box_plot(category_cols, labels=None, title='Box Plot', x_label='Categories', y_label='Values', num_ticks=5, colour='#4e79a7', margin=60, filename='box_plot.html', open_browser=False)"
    },
    "calculator_help": {
        "name": "calculator_help",
        "category": "Table",
        "signature": "(self, terminal=False)",
        "doc": "Display help for the column calculator. Generates an HTML document by default.\n\nParameters:\n\nterminal (Boolean): flag to indicate if the help will be printed to a terminal or written as a file.",
        "example": "result = table.calculator_help(terminal=False)"
    },
    "check_date_continuity": {
        "name": "check_date_continuity",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Check whether a column of dates ('column') forms a continuous, gap-free daily sequence from the earliest date to the latest date and return True or False.\n\nParameters:\n\ncolumn (integer, string): the index or header of the date column to be checked.",
        "example": "result = table.check_date_continuity(column)"
    },
    "check_missing_invalid": {
        "name": "check_missing_invalid",
        "category": "Table",
        "signature": "(self, missing_invalid='')",
        "doc": "Check each column for missing or invalid values ('missing_invalid') and return a list of column indices that have missing or invalid values.\n\nParameters:\n\nmissing_invalid (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = table.check_missing_invalid(missing_invalid='')"
    },
    "clear_data": {
        "name": "clear_data",
        "category": "Table",
        "signature": "(self)",
        "doc": "Remove the data, headers, and data types stored in the Table object.",
        "example": "table.clear_data()"
    },
    "column_calculator": {
        "name": "column_calculator",
        "category": "Table",
        "signature": "(self, expression, column=None, missing_invalid='', in_place=True, new_header=None, decimals=2)",
        "doc": "Evaluate a specified expression ('expression') for each row in the Table object using column references, row-level functions such as mathematical and conditional operators, column-level scalar, and column transformers. The results of the calculator can overwrite a target column or be appended as a new column. The helper function calculator_help() may be called to explain calculator syntax and available functions.\n\nParameters:\n\nexpression (string): the expression to evaluate. \n\ncolumn (integer, string): the target column the calculator results will be written to if the in_place flag is True.\n\nmissing_invalid (string, list): a string or list of values specifying missing or invalid values in the Table. If a missing or invalid value is present in a row, the column calculator will skip that row.\n\nin_place (Boolean): flag to indicate if the results of the column calculator will overwrite the target column. Calculator results will be appended as a new column if flag is False.\n\nnew_header (string): if in_place flag is False, the header of the new column to be appended.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.column_calculator(expression, column=None, missing_invalid='', in_place=True, new_header=None, decimals=2)"
    },
    "column_exists": {
        "name": "column_exists",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Determine if the specified column ('column') exists in the Table object. Returns True or False.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be checked.",
        "example": "result = table.column_exists(column)"
    },
    "column_index": {
        "name": "column_index",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Return the index of a specified column ('column') if it exists in the Table object.\n\nParameters:\n\ncolumn (string): the header of the column to determine the index of.",
        "example": "result = table.column_index(column)"
    },
    "column_index_of_val": {
        "name": "column_index_of_val",
        "category": "Table",
        "signature": "(self, row, value)",
        "doc": "Return the column index of a specified value ('value') in a specified row ('row'). Only the first index where the value appears will be returned.\n\nParameters:\n\nrow (integer): the row to check for the specified value index.\n\nvalue (integer, float, string): the value to search for. Only the first index of where the value appears will be returned.",
        "example": "result = table.column_index_of_val(row, value)"
    },
    "column_indices_of_val": {
        "name": "column_indices_of_val",
        "category": "Table",
        "signature": "(self, row, value)",
        "doc": "Return the column indices of a specified value ('value') in a specified row ('row'). All indices where the value appears will be returned as a list.\n\nParameters:\n\nrow (integer): the row to check for the specified value index.\n\nvalue (integer, float, string): the value to search for. All indices of the target value will be returned.",
        "example": "result = table.column_indices_of_val(row, value)"
    },
    "column_stat": {
        "name": "column_stat",
        "category": "Table",
        "signature": "(self, column, stat, decimals=2)",
        "doc": "Calculate and return the specified descriptive statistic ('stat') of the specified column ('column'). Only numeric values (integer or float) in the specified column will be included in the calculation.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nstat (string): the specific statistic to return. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.column_stat(column, stat, decimals=2)"
    },
    "column_stats_list": {
        "name": "column_stats_list",
        "category": "Table",
        "signature": "(self, stat, decimals=2)",
        "doc": "Calculate the specified descriptive statistic ('stat') of each column in the Table and return a list of statistics. Only numeric values (integer or float) in each column will be included in the calculation.\n\nParameters:\n\nstat (string): the specific statistic to calculate for each column. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.column_stats_list(stat, decimals=2)"
    },
    "column_subset": {
        "name": "column_subset",
        "category": "Table",
        "signature": "(self, columns)",
        "doc": "Return a new Table object that includes only the specified columns ('columns').\n\nParameters:\n\ncolumns (list): the list of column headers or columns indices to subset in the output Table.",
        "example": "result = table.column_subset(columns)"
    },
    "column_summary": {
        "name": "column_summary",
        "category": "Table",
        "signature": "(self, column, terminal=False, decimals=2)",
        "doc": "Calculate all descriptive statistics of the specified column ('column') and return a dictionary of all statistics. Only numeric values (integer or float) in the specified column will be included in the calculation.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nterminal (Boolean): flag to indicate if the result will be printed to a terminal or just returned.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.column_summary(column, terminal=False, decimals=2)"
    },
    "compare": {
        "name": "compare",
        "category": "Table",
        "signature": "(self, table, summary=True)",
        "doc": "Compare this Table with another Table object ('Table') and return a dictionary of structural differences. Returns a dictionary with keys: 'rows', 'columns', 'columns_only_in_self', 'columns_only_in_other', 'columns_in_both', 'column_type_differences', and 'column_order_matches'. Results are ordered self and other.\n\nParameters:\n\ntable (object): the Table object to compare against.\n\nsummary (Boolean): flag to indicate if a summary of the comparison will be printed. If False, only returns a dictionary of results.",
        "example": "result = table.compare(table, summary=True)"
    },
    "convert_dtype": {
        "name": "convert_dtype",
        "category": "Table",
        "signature": "(self, column, dtype)",
        "doc": "Convert the data type of a single column to another data type.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be converted.\n\ndtype (string): the data type to convert the column to. Can be specified as \"integer\" for integer data, \"float\" for float data, \"string\" for string data, or \"bool\" for Boolean data.",
        "example": "table.convert_dtype(column, dtype)"
    },
    "copy": {
        "name": "copy",
        "category": "Table",
        "signature": "(self)",
        "doc": "Copy the headers, data types, and data of the Table and return a new Table object.",
        "example": "result = table.copy()"
    },
    "count_in_column": {
        "name": "count_in_column",
        "category": "Table",
        "signature": "(self, column, value)",
        "doc": "Count and return the number of occurrences of a specified value ('value') in the specified column ('column').\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to count the specified value in.\n\nvalue (integer, float, string): the value to count.",
        "example": "result = table.count_in_column(column, value)"
    },
    "count_in_row": {
        "name": "count_in_row",
        "category": "Table",
        "signature": "(self, row, value)",
        "doc": "Count and return the number of occurrences of a specified value ('value') in the specified row ('row').\n\nParameters:\n\nrow (integer): the row to count the specified value in.\n\nvalue (integer, float, string): the value to count.",
        "example": "result = table.count_in_row(row, value)"
    },
    "date_intersection": {
        "name": "date_intersection",
        "category": "Table",
        "signature": "(self, table, date_col1, date_col2)",
        "doc": "Determine if the date column of another Table object ('table') overlaps with the date column of this Table and return both tables filtered by the overlapping range. It is assumed that the date ranges of each table are sorted in order. Returns a tuple of (filtered_table1, filtered_table2). If there is no overlap between the date ranges of the tables, a tuple of (None, None) is returned.\n\nParameters:\n\ntable (object): the Table object the operation will be performed on. The input Table will not be altered by the operation.\n\ndate_col1 (integer, string): the index or header of the date column in this Table. Date column must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts.\n\ndate_col2 (integer, string): the index or header of the date column in the other Table. Date column must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts.",
        "example": "result = table.date_intersection(table, date_col1, date_col2)"
    },
    "date_to_iso": {
        "name": "date_to_iso",
        "category": "Table",
        "signature": "(self, column, formats, new_header=None)",
        "doc": "Convert a specified column ('column') to ISO format (yyyy-mm-dd) and either append a new column or overwrite an existing column.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nformats (string, list): a string or list of strings of date formats to attempt to convert to ISO format.\n\nnew_header (string): if a string is given, a new column of converted ISO dates will be appended to the end of the data with the specified header. If left as None, the target date column will be overwritten with converted ISO dates.",
        "example": "table.date_to_iso(column, formats, new_header=None)"
    },
    "detect_dtypes": {
        "name": "detect_dtypes",
        "category": "Table",
        "signature": "(self)",
        "doc": "Automatically detect the data type of each column and set the Table data types.",
        "example": "table.detect_dtypes()"
    },
    "dimensions": {
        "name": "dimensions",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return a tuple of (rows, columns), representing the total number of rows and columns in the data.",
        "example": "result = table.dimensions()"
    },
    "display_columns": {
        "name": "display_columns",
        "category": "Table",
        "signature": "(self, start_col=None, end_col=None)",
        "doc": "Print a range of columns. The specified range is inclusive.\n\nParameters:\n\nstart_col (integer): the index of the first column to be displayed. If None start_col defaults to 0.\n\nend_col (integer): the index of the last column to be displayed. The range specified by start_col and end_col is inclusive. If None end_col defaults to the number of the columns.",
        "example": "table.display_columns(start_col=None, end_col=None)"
    },
    "display_head": {
        "name": "display_head",
        "category": "Table",
        "signature": "(self, num_rows=10)",
        "doc": "Print the first rows ('num_rows') of the Table.\n\nParameters:\n\nnum_rows (integer): the number of first rows to be printed.",
        "example": "table.display_head(num_rows=10)"
    },
    "display_rows": {
        "name": "display_rows",
        "category": "Table",
        "signature": "(self, start_row=None, end_row=None)",
        "doc": "Print a range of rows. The specified range is inclusive.\n\nParameters:\n\nstart_row (integer): the index of the first row to be displayed. If None start_row defaults to 0.\n\nend_row (integer): the index of the last row to be displayed. The range specified by start_row and end_row is inclusive. If None end_row defaults to the length of the data.",
        "example": "table.display_rows(start_row=None, end_row=None)"
    },
    "display_sample": {
        "name": "display_sample",
        "category": "Table",
        "signature": "(self, num_rows=10)",
        "doc": "Extract and print a sample of rows ('num_rows').\n\nParameters:\n\nnum_rows (integer): the number of first rows to be printed.",
        "example": "table.display_sample(num_rows=10)"
    },
    "display_tail": {
        "name": "display_tail",
        "category": "Table",
        "signature": "(self, num_rows=10)",
        "doc": "Print the last rows ('num_rows') of the Table.\n\nParameters:\n\nnum_rows (integer): the number of last rows to be printed.",
        "example": "table.display_tail(num_rows=10)"
    },
    "dissolve_rows": {
        "name": "dissolve_rows",
        "category": "Table",
        "signature": "(self, dissolve_on, dissolve_columns=None, methods=None, sep='', decimals=2)",
        "doc": "Aggregate rows with duplicate values in a specified column ('dissolve_on') into single rows and return a new Table. Values from other columns ('dissolve_columns') in the dissolved rows may be aggregated according to a specified method.\n\nParameters:\n\ndissolve_on (integer, string): the index or header of the column with duplicate values to dissolve rows by.\n\ndissolve_columns (integer, string, list): the other column or columns in each duplicate row whose values will be combined according to a method. Can be left blank to include all columns. For a single column, can be specified as the index or header of a column. For multiple columns, can be specified as a list of column indices or headers. Columns not specified will be aggregated by the default \"First\" method.\n\nmethods (string, list): If a single dissolve column is specified or no dissolve columns are specified (all columns will be included), this should be a string representing the method used to aggregate values. If multiple dissolve columns are specified, this should be a list of strings representing the aggregation method for each column. Possible aggregation methods are \"First\", \"Last\", \"Count\", \"Unique\", \"Sum\", \"Min\", \"Max\", \"Range\", \"Mean\", \"Median\", \"Mode, \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", \"Kurtosis\", or \"Concatenate\". May be left blank to use \"First\" as the default aggregation method. The 'dissolve_on' column will always use the \"First\" method.\n\nsep (string): If the Concatenate aggregation method is used for any dissolve columns, a separator may be specified so that aggregated values can be retrieved as a string and split at the separator.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.dissolve_rows(dissolve_on, dissolve_columns=None, methods=None, sep='', decimals=2)"
    },
    "drop_column": {
        "name": "drop_column",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Remove a single specified column from the data.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be removed.",
        "example": "table.drop_column(column)"
    },
    "duplicate_column": {
        "name": "duplicate_column",
        "category": "Table",
        "signature": "(self, column, duplicates)",
        "doc": "Duplicate a specified column of data.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be duplicated. Columns after the duplicated columns will be shifted to the right.\n\nduplicates (integer): the number of times to duplicate the specified column.",
        "example": "table.duplicate_column(column, duplicates)"
    },
    "duplicate_row": {
        "name": "duplicate_row",
        "category": "Table",
        "signature": "(self, row, duplicates)",
        "doc": "Duplicate a specified row of data.\n\nParameters:\n\nrow (integer): the index of the row to be duplicated. Rows after the duplicated rows will be shifted down.\n\nduplicates (integer): the number of times to duplicate the specified row.",
        "example": "table.duplicate_row(row, duplicates)"
    },
    "fill_data_backward": {
        "name": "fill_data_backward",
        "category": "Table",
        "signature": "(self, column, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the valid value immediately following each missing or invalid value. This method will not be able to fill missing or invalid values in the last row.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "table.fill_data_backward(column, to_fill='')"
    },
    "fill_data_column_stat": {
        "name": "fill_data_column_stat",
        "category": "Table",
        "signature": "(self, column, stat, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the specified statistics ('stat') of all valid values within that column. Missing or invalid values will be interpolated as floats.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nstat (string): the specific statistic to return. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.fill_data_column_stat(column, stat, to_fill='', decimals=2)"
    },
    "fill_data_forward": {
        "name": "fill_data_forward",
        "category": "Table",
        "signature": "(self, column, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the valid value immediately preceding each missing or invalid value. This method will not be able to fill missing or invalid values in the first row.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "table.fill_data_forward(column, to_fill='')"
    },
    "fill_data_from_column": {
        "name": "fill_data_from_column",
        "category": "Table",
        "signature": "(self, column, other_col, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the corresponding row value from another column ('other_col'). The column data type will be redetermined.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nother_col (integer, string): the index or header of the column that will be used to fill missing values in the column of operation.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "table.fill_data_from_column(column, other_col, to_fill='')"
    },
    "fill_data_from_list": {
        "name": "fill_data_from_list",
        "category": "Table",
        "signature": "(self, column, fill_list, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the corresponding value from an input list ('fill_list'). The input list must be the same length as the column to be filled. The column data type will be redetermined.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nfill_list (list): the list of values that will be used to fill missing values in the column of operation. The input list must be the same length as the column to be filled.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "table.fill_data_from_list(column, fill_list, to_fill='')"
    },
    "fill_data_inverse_distance_weighted": {
        "name": "fill_data_inverse_distance_weighted",
        "category": "Table",
        "signature": "(self, column, distance, power=2, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using an inverse distance weighted (IDW) technique. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\ndistance (integer): the number of values before and after each missing or invalid value to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\npower (integer): the power of the inverse distance weighting function. Higher values will give greater weight to nearer values i.e. nearer values will contribute more strongly to the interpolated value.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.fill_data_inverse_distance_weighted(column, distance, power=2, to_fill='', decimals=2)"
    },
    "fill_data_linear_interpolation": {
        "name": "fill_data_linear_interpolation",
        "category": "Table",
        "signature": "(self, column, to_fill='', direction='forward')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using a linear interpolation technique. This method will not be able to fill missing or invalid values at either the beginning or end of the column, depending on the direction of interpolation.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndirection (string): the direction of interpolation applied after the linear interpolation. May be specified as \"forward\" for a forward interpolation (missing or invalid values at the beginning of the column will not be interpolated) or \"backward\" for a backward interpolation (missing or invalid values at the end of the column will not be interpolated).",
        "example": "table.fill_data_linear_interpolation(column, to_fill='', direction='forward')"
    },
    "fill_data_mean_distance": {
        "name": "fill_data_mean_distance",
        "category": "Table",
        "signature": "(self, column, distance, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the average of valid values before and after each missing or invalid value. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\ndistance (integer): the number of values before and after each missing or invalid value to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.fill_data_mean_distance(column, distance, to_fill='', decimals=2)"
    },
    "fill_data_regression": {
        "name": "fill_data_regression",
        "category": "Table",
        "signature": "(self, column, vals, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') by performing a linear regression between the values of the specified column and a second list ('vals'). Missing or invalid values will be interpolated as floats.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nvals (list): the list of values to perform a linear regression with for interpolation. Only valid (numeric) values within this list will be used for interpolation. Should be the same length or longer than the specified column.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.fill_data_regression(column, vals, to_fill='', decimals=2)"
    },
    "fill_data_rolling_average": {
        "name": "fill_data_rolling_average",
        "category": "Table",
        "signature": "(self, column, window, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using the average of valid values within a rolling window of previous rows. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nwindow (integer): the number of previous values to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.fill_data_rolling_average(column, window, to_fill='', decimals=2)"
    },
    "fill_data_single_value": {
        "name": "fill_data_single_value",
        "category": "Table",
        "signature": "(self, column, fill_val, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified column ('column') using a single specified value ('fill_val').\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nfill_val (integer, float, string): the new value that will replace missing or invalid values.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "table.fill_data_single_value(column, fill_val, to_fill='')"
    },
    "filter_boolean": {
        "name": "filter_boolean",
        "category": "Table",
        "signature": "(self, column, condition, target)",
        "doc": "Filter the Table data by removing rows that do not meet a specified Boolean condition and return a new Table object.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to filter by.\n\ncondition (string): the condition used to evaluate each Boolean value. Must be \"==\" for equality or \"!=\" for inequality.\n\ntarget (bool): the Boolean value to compare against.",
        "example": "result = table.filter_boolean(column, condition, target)"
    },
    "filter_date": {
        "name": "filter_date",
        "category": "Table",
        "signature": "(self, column, condition, threshold)",
        "doc": "Filter the Table data by removing rows that do not meet a specified threshold condition and return a new Table object. This filtering operation is performed with columns of date values, which must be in \"yyyy-mm-dd\" format.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to filter Table data by. Date values in this column must be in \"yyyy-mm-dd\" format\n\ncondition (string): the condition placed upon each value in the specified column to determine inclusion in the filtered data. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.\n\nthreshold (string): the threshold to evaluate each value in the specified column against to determine inclusion in the filtered data. Must be in \"yyyy-mm-dd\" format.",
        "example": "result = table.filter_date(column, condition, threshold)"
    },
    "filter_missing_invalid": {
        "name": "filter_missing_invalid",
        "category": "Table",
        "signature": "(self, to_remove='')",
        "doc": "Filter the Table data by removing rows that contain missing or invalid values ('to_remove') and return a new Table.\n\nParameters:\n\nto_remove (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = table.filter_missing_invalid(to_remove='')"
    },
    "filter_numeric": {
        "name": "filter_numeric",
        "category": "Table",
        "signature": "(self, column, condition, threshold)",
        "doc": "Filter the Table data by removing rows that do not meet a specified threshold condition and return a new Table object. This filtering operation is performed with columns of numeric values.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to filter Table data by.\n\ncondition (string): the condition placed upon each value in the specified column to determine inclusion in the filtered data. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.\n\nthreshold (integer, float): the threshold to evaluate each value in the specified column against to determine inclusion in the filtered data.",
        "example": "result = table.filter_numeric(column, condition, threshold)"
    },
    "filter_text": {
        "name": "filter_text",
        "category": "Table",
        "signature": "(self, column, condition, threshold)",
        "doc": "Filter the Table data by removing rows that do not meet a specified threshold condition and return a new Table object. This filtering operation is performed with columns of string (text) values.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to filter Table data by.\n\ncondition (string): the condition placed upon each value in the specified column to determine inclusion in the filtered data. May be specified as \"==\" for equal to, \"!=\" for not equal to, 'like' for contains, \"not like\" for does not contain, 'start' for starts with, 'not start' for does not start with, 'end' for ends with, or 'not end' for does not end with. Conditions are case sensitive.\n\nthreshold (string): the threshold to evaluate each value in the specified column against to determine inclusion in the filtered data.",
        "example": "result = table.filter_text(column, condition, threshold)"
    },
    "filter_type": {
        "name": "filter_type",
        "category": "Table",
        "signature": "(self, column, condition, dtype)",
        "doc": "Filter the Table data by removing rows that do not meet a specified data type condition and return a new Table object. This filtering operation is performed with columns of specific data types.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to filter Table data by.\n\ncondition (string): the condition placed upon each value in the specified column to determine inclusion in the filtered data. May be specified as \"is\" to include values that match the data type, or \"is not\" to include values that do not match.\n\ndtype (string): the data type to evaluate each value in the specified column against to determine inclusion in the filtered data. Possible types include \"int\", \"float\", \"string\", \"bool\", and \"nan\".",
        "example": "result = table.filter_type(column, condition, dtype)"
    },
    "generate_id_col": {
        "name": "generate_id_col",
        "category": "Table",
        "signature": "(self, header='ID', start=1, step=1, index=0)",
        "doc": "Generate an ID column of unique integer values.\n\nParameters:\n\nheader (string): the header of the ID column.\n\nstart (integer): the first value of the ID column.\n\nstep (integer): the difference between subsequent values. May be positive (for addition) or negative (for subtraction).\n\nindex (integer): the index where the column will be inserted.",
        "example": "table.generate_id_col(header='ID', start=1, step=1, index=0)"
    },
    "get_column": {
        "name": "get_column",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Return the values of a specified column as a list.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be returned.",
        "example": "result = table.get_column(column)"
    },
    "get_columns": {
        "name": "get_columns",
        "category": "Table",
        "signature": "(self, columns)",
        "doc": "Return the values of each specified column as a list.\n\nParameters:\n\ncolumn (list): a list of the indices or headers of the columns to be returned.",
        "example": "result = table.get_columns(columns)"
    },
    "get_data": {
        "name": "get_data",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return all rows of data in the Table object as a nested list, not including column headers.",
        "example": "result = table.get_data()"
    },
    "get_date_range": {
        "name": "get_date_range",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Return a tuple of (start date, end date) from the specified column of dates.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.",
        "example": "result = table.get_date_range(column)"
    },
    "get_dtypes": {
        "name": "get_dtypes",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return the data types of each column as a list.",
        "example": "result = table.get_dtypes()"
    },
    "get_headers": {
        "name": "get_headers",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return the columns headers.",
        "example": "result = table.get_headers()"
    },
    "get_row": {
        "name": "get_row",
        "category": "Table",
        "signature": "(self, row)",
        "doc": "Return the values of a specified row as a list.\n\nParameters:\n\nrow (integer): the index of the row to be returned.",
        "example": "result = table.get_row(row)"
    },
    "get_rows": {
        "name": "get_rows",
        "category": "Table",
        "signature": "(self, rows)",
        "doc": "Return a list of rows, each a list of values.\n\nParameters:\n\nrows (list): a list of indices of the rows to be returned.",
        "example": "result = table.get_rows(rows)"
    },
    "get_sample": {
        "name": "get_sample",
        "category": "Table",
        "signature": "(self, num_rows)",
        "doc": "Get a random sample of rows ('num_rows') and return a new Table object. Column headers and data types are transferred to the new Table.\n\nParameters:\n\nnum_rows (integer): the number of rows in the new Table.",
        "example": "result = table.get_sample(num_rows)"
    },
    "get_value": {
        "name": "get_value",
        "category": "Table",
        "signature": "(self, row, column)",
        "doc": "Return a value at the specified position in the data.\n\nParameters:\n\nrow (integer): the index of the row of the value to be returned.\n\ncolumn (integer. string): the index or header of the column of the value to be returned.",
        "example": "result = table.get_value(row, column)"
    },
    "histogram": {
        "name": "histogram",
        "category": "Table",
        "signature": "(self, column, title='Histogram', x_label='Value', y_label='Frequency', num_bins=None, bar_colour=None, margin=60, filename='histogram.html', open_browser=False)",
        "doc": "Create a histogram for a single column and configure plot elements.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be visualized.\n\ntitle (string): the title of the histogram.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_bins (integer, optional): the number of bins to divide the data into. If not specified, the optimal number of bins is calculated using Sturge's Formula.\n\nbar_colour (string, optional): the colour of the bars. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.histogram(column, title='Histogram', x_label='Value', y_label='Frequency', num_bins=None, bar_colour=None, margin=60, filename='histogram.html', open_browser=False)"
    },
    "info": {
        "name": "info",
        "category": "Table",
        "signature": "(self)",
        "doc": "Print a summary of the Table object, including number of rows, number of columns, column headers, data types, and memory footprint.",
        "example": "result = table.info()"
    },
    "insert_column": {
        "name": "insert_column",
        "category": "Table",
        "signature": "(self, vals, index, col_header)",
        "doc": "Insert a new column of values ('vals') in the data at the specified index ('index'). This function can also be used to add a first column of data to a new Table object.\n\nParameters:\n\nvals (list): the column of values to be inserted.\n\nindex (integer): the index where the column will be inserted. Columns after the inserted column will be shifted to the right.\n\ncol_header (string): the name of the header for the new column.",
        "example": "table.insert_column(vals, index, col_header)"
    },
    "insert_columns": {
        "name": "insert_columns",
        "category": "Table",
        "signature": "(self, vals, index, col_headers)",
        "doc": "Insert new columns of values ('vals') in the data at the specified index ('index'). This function can also be used to add the first columns of data to a new Table object.\n\nParameters:\n\nvals (list): a nested list of column values to be inserted. Each inner list must match the number of rows if the table is not empty.\n\nindex (integer): the index where the first column will be inserted. Columns after the inserted columns will be shifted to the right.\n\ncol_headers (list): a list of headers for the new columns.",
        "example": "table.insert_columns(vals, index, col_headers)"
    },
    "insert_missing_date_values": {
        "name": "insert_missing_date_values",
        "category": "Table",
        "signature": "(self, column, placeholder='')",
        "doc": "Insert rows into the Table wherever dates are missing from the specified date column ('date_column'). The date column will receive the missing date, and all other columns will receive the specified placeholder.\n\nParameters:\n\ncolumn (integer, string): the index or header of the date column.\n\nplaceholder: the value to insert for non-date columns in the new rows. Default is \"\".",
        "example": "result = table.insert_missing_date_values(column, placeholder='')"
    },
    "insert_row": {
        "name": "insert_row",
        "category": "Table",
        "signature": "(self, vals, index)",
        "doc": "Insert a new row of values ('vals') in the data at the specified index ('index').\n\nParameters:\n\nvals (list): the row of values to be inserted. If the Table is not empty, new row must be the same length as the number of columns.\n\nindex (integer): the index where the row will be inserted. Rows after the inserted row will be shifted down.",
        "example": "table.insert_row(vals, index)"
    },
    "insert_rows": {
        "name": "insert_rows",
        "category": "Table",
        "signature": "(self, vals, index)",
        "doc": "Insert multiple rows of values ('vals') in the data at the specified index ('index').\n\nParameters:\n\nvals (list): the list of rows to be inserted. If the Table is not empty, each row must be the same length as the number of columns.\n\nindex (integer): the index where the rows will be inserted. Rows at and after the inserted rows will be shifted down.",
        "example": "table.insert_rows(vals, index)"
    },
    "is_empty": {
        "name": "is_empty",
        "category": "Table",
        "signature": "(self)",
        "doc": "Returns True if this Table object has no data and False otherwise.",
        "example": "result = table.is_empty()"
    },
    "join_table": {
        "name": "join_table",
        "category": "Table",
        "signature": "(self, to_join, primary_key, foreign_key, columns)",
        "doc": "Join the data of this Table object with the data from another Table object ('to_join'), based on a primary key and foreign key. This join function is a left outer join, using a one-to-one relationship only (i.e., other join types and relationships are not supported).\n\nParameters:\n\nto_join (object): the Table object to join to this Table object.\n\nprimary_key (string): the column header of the column in this Table object that serves as the unique identifier.\n\nforeign_key (string): the column header of the column in the \"to_join\" object that corresponds with the primary key of this Table. Must be the same data type as the primary key.\n\ncolumns (list, string): a list of strings representing the column headers of the columns in the \"to_join\" data to be joined to this Table. May be specified as the string \"all\" to include all available columns.",
        "example": "table.join_table(to_join, primary_key, foreign_key, columns)"
    },
    "line_plot": {
        "name": "line_plot",
        "category": "Table",
        "signature": "(self, x_col, y_cols, title='Line Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, line_weight=2, line_colours=None, trendline=False, trend_colours=None, legend=False, line_labels=None, margin=60, filename='line_plot.html', open_browser=False)",
        "doc": "Create a line plot for a single independent variable ('x_col') column and one or more dependent variables ('y_col') and configure plot elements.\n\nParameters:\n\nx_col (integer, string): the index or header of the column representing the independent variable to be visualized. Values may be numerical (integer or floating point) or categorical strings such as dates.\n\ny_cols (integer, string, list): the index or header of a single column representing the dependent variable to be visualized, or a list of columns indices or headers if there are multiple dependent variables to be visualized. Values must be numerical (integer or floating point).\n\ntitle (string): the title of the line plot.  \n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.  \n\nnum_ticks (integer): the number of tick marks to draw on each axis.\n\nline_weight (integer): the stroke width of the lines on the plot (in pixels).\n\nline_colours (string, list): if a single dependent variable is given, this should be a single string representing the colour of the line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each variable. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\ntrendline (Boolean): flag to indicate if trend lines for each dependent variable will be calculated and displayed.\n\ntrend_colours (string, list): if a single dependent variable is given, this should be a single string representing the colour of the trend line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each trend line. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\nline_labels (string, list): the labels of each dependent variable series. If no labels are given, generic labels (\"Series 1\", \"Series 2\", ...) will be generated. A legend must be created to view series labels.\n\nmargin (integer): the margin size (in pixels) around the plot area.  \n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.line_plot(x_col, y_cols, title='Line Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, line_weight=2, line_colours=None, trendline=False, trend_colours=None, legend=False, line_labels=None, margin=60, filename='line_plot.html', open_browser=False)"
    },
    "map_column": {
        "name": "map_column",
        "category": "Table",
        "signature": "(self, column, func, args=None, kwargs=None)",
        "doc": "Apply a user-defined function ('func') to an entire column ('column') and return the result.\n\nThe function ('func') receives the full list of column values as its first argument. The function may return any type of object, including a list of any length, a scalar, or a complex structure. The Table is not modified.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be passed to the function.\n\nfunc (callable): the function that accepts a list of values and returns any result.\n\nargs (tuple): additional positional arguments to pass to the user-defined function. No lambda expressions are required.\n\nkwargs (dict, optional): additional keyword arguments to pass to the user-defined function. No lambda expressions are required.",
        "example": "result = table.map_column(column, func, args=None, kwargs=None)"
    },
    "map_row": {
        "name": "map_row",
        "category": "Table",
        "signature": "(self, row, func, args=None, kwargs=None)",
        "doc": "Apply a user-defined function ('func') to an entire row ('row') and return the result. The function ('func') receives the full list of row values as its first argument. The function may return any type of object, including a list of any length, a scalar, or a complex structure. The Table is not modified.\n\nParameters:\n\nrow (integer): the index of the row to be passed to the function.\n\nfunc (callable): the function that accepts a list of values and returns any result.\n\nargs (tuple): additional positional arguments to pass to the user-defined function. No lambda expressions are required.\n\nkwargs (dict, optional): additional keyword arguments to pass to the user-defined function. No lambda expressions are required.",
        "example": "result = table.map_row(row, func, args=None, kwargs=None)"
    },
    "normalize_dates": {
        "name": "normalize_dates",
        "category": "Table",
        "signature": "(self, column, sep='-', new_header=None)",
        "doc": "Normalize separators in a column of dates ('column') to a consistent ISO-style format and either append a new column or overwrite an existing column.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nsep (string): the separator to use in the normalized output. Default is '-'.\n\nnew_header (string): if a string is given, a new column of normalized ISO dates will be appended to the end of the data with the specified header. If left as None, the target date column will be overwritten with normalized ISO dates.",
        "example": "table.normalize_dates(column, sep='-', new_header=None)"
    },
    "num_columns": {
        "name": "num_columns",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return the total number of columns in the data.",
        "example": "result = table.num_columns()"
    },
    "num_rows": {
        "name": "num_rows",
        "category": "Table",
        "signature": "(self)",
        "doc": "Return the total number of rows in the data",
        "example": "result = table.num_rows()"
    },
    "open_viewer": {
        "name": "open_viewer",
        "category": "Table",
        "signature": "(self)",
        "doc": "Open an interactive browser-based data viewer with spreadsheet-style navigation and cell editing. Script execution pauses until the browser is closed. \nEdits are not saved to the Table data unless explicitly saved by clicking the Save button. Closing the browser discards any unsaved edits.\n\nNavigation:\n- Click once to select a cell\n- Double-click (or press F2) to edit the selected cell\n- Arrow keys move between cells (when not editing)\n- Enter moves down; Shift+Enter moves up\n- Tab moves right; Shift+Tab moves left\n- While editing, arrow keys move the text cursor within the cell\n- Press Enter to commit an edit, or Esc to cancel it\n- Drag the small handle on the right edge of any column header to resize it.",
        "example": "result = table.open_viewer()"
    },
    "pie_chart": {
        "name": "pie_chart",
        "category": "Table",
        "signature": "(self, column, title='Pie Chart', show_values=False, colours=None, legend=True, margin=60, filename='pie_chart.html', open_browser=False)",
        "doc": "Create a pie chart from a column of categorical values ('column') and configure chart elements.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be visualized. \n\ntitle (string): the title of the pie chart.\n\nshow_values (Boolean): flag to indicate if counts and percentages should be shown in the legend beside each category label. If False, only category names are shown.\n\ncolours (list): list of colour strings to use for slices. If None, colours are auto-generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.pie_chart(column, title='Pie Chart', show_values=False, colours=None, legend=True, margin=60, filename='pie_chart.html', open_browser=False)"
    },
    "pivot": {
        "name": "pivot",
        "category": "Table",
        "signature": "(self, index, columns, values)",
        "doc": "Pivot the table from long to wide format and return a new Table.\n\nParameters:\n\nindex (integer, string): the index or header of the column to use as row identifiers.\n\ncolumns (integer, string): the index or header of the column whose unique values become new headers.\n\nvalues (integer, string): the index or header of the column whose values fill the new table.",
        "example": "result = table.pivot(index, columns, values)"
    },
    "pop_column": {
        "name": "pop_column",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Return the values of the specified column as a list and remove the column from the data.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be returned.",
        "example": "result = table.pop_column(column)"
    },
    "pop_row": {
        "name": "pop_row",
        "category": "Table",
        "signature": "(self, row)",
        "doc": "Return the values of a specified row as a list and remove the row from the data.\n\nParameters:\n\nrow (integer): the index of the row to be returned.",
        "example": "result = table.pop_row(row)"
    },
    "remove_columns": {
        "name": "remove_columns",
        "category": "Table",
        "signature": "(self, start_col, end_col)",
        "doc": "Remove a range of columns from the data.\n\nParameters:\n\nstart_col (integer): the index of the first column to be removed.\n\nend_col (integer): the index of the last column to be removed. The range specified by start_col and end_col is inclusive.",
        "example": "table.remove_columns(start_col, end_col)"
    },
    "remove_duplicate_columns": {
        "name": "remove_duplicate_columns",
        "category": "Table",
        "signature": "(self)",
        "doc": "Remove all duplicate columns from the data.",
        "example": "table.remove_duplicate_columns()"
    },
    "remove_duplicate_rows": {
        "name": "remove_duplicate_rows",
        "category": "Table",
        "signature": "(self)",
        "doc": "Remove all duplicate rows from the data. The first occurrence of each duplicate is presereved.",
        "example": "table.remove_duplicate_rows()"
    },
    "remove_header_space": {
        "name": "remove_header_space",
        "category": "Table",
        "signature": "(self)",
        "doc": "Replace spaces in header names with underscores. This is necessary when writing data to an SQL database table if the headers have spaces.",
        "example": "table.remove_header_space()"
    },
    "remove_rows": {
        "name": "remove_rows",
        "category": "Table",
        "signature": "(self, start_row, end_row)",
        "doc": "Remove a range of rows from the data.\n\nParameters:\n\nstart_row (integer): the index of the first row to be removed.\n\nend_row (integer): the index of the last row to be removed. The range specified by start_row and end_row is inclusive.",
        "example": "table.remove_rows(start_row, end_row)"
    },
    "rename_column": {
        "name": "rename_column",
        "category": "Table",
        "signature": "(self, column, new_header)",
        "doc": "Replace an existing column header ('column') with a new header ('new_header').\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to give a new header to.\n\nnew_header (string): the new header for the column. If new_header is not a string it will be converted to a string.",
        "example": "table.rename_column(column, new_header)"
    },
    "replace_column": {
        "name": "replace_column",
        "category": "Table",
        "signature": "(self, column, vals, col_header)",
        "doc": "Replace an existing column ('column') with a new column ('vals').\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be replaced.\n\nvals (list): the list of values to replace the old column.\n\ncol_header (string): the name of the header for the new column.",
        "example": "table.replace_column(column, vals, col_header)"
    },
    "replace_row": {
        "name": "replace_row",
        "category": "Table",
        "signature": "(self, row, vals)",
        "doc": "Replace an existing row ('row') with a new row ('vals').\n\nParameters:\n\nrow (integer): the index of the row to be replaced.\n\nvals (list): the row of values to replace the old row. Row must match the number of columns.",
        "example": "table.replace_row(row, vals)"
    },
    "reshape": {
        "name": "reshape",
        "category": "Table",
        "signature": "(self, row=None, col=None)",
        "doc": "Modify the number of rows and columns in the data by removing rows and columns beyond the specified row ('row') and column ('col') indices.\n\nParameters:\n\nrow (integer): the index of the last row to preserve. All rows beyond this index will be removed.\n\ncol (integer): the index of the last column to preserve. All columns beyond this index will be removed.",
        "example": "table.reshape(row=None, col=None)"
    },
    "reverse_columns": {
        "name": "reverse_columns",
        "category": "Table",
        "signature": "(self)",
        "doc": "Reverse the order of all columns in the data.",
        "example": "table.reverse_columns()"
    },
    "reverse_rows": {
        "name": "reverse_rows",
        "category": "Table",
        "signature": "(self)",
        "doc": "Reverse the order of all rows in the data.",
        "example": "table.reverse_rows()"
    },
    "round_column": {
        "name": "round_column",
        "category": "Table",
        "signature": "(self, column, decimals=2)",
        "doc": "Round the values in a specified column ('column') to a specified number of decimal places ('decimals'). Only numeric values (integer or float) in the specified column will be rounded.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "table.round_column(column, decimals=2)"
    },
    "row_index_of_val": {
        "name": "row_index_of_val",
        "category": "Table",
        "signature": "(self, column, value)",
        "doc": "Return the row index of a specified value ('value') in a specified column ('column'). Only the first index where the value appears will be returned.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nvalue (integer, float, string): the value to search for. Only the first index of where the value appears will be returned.",
        "example": "result = table.row_index_of_val(column, value)"
    },
    "row_indices_of_val": {
        "name": "row_indices_of_val",
        "category": "Table",
        "signature": "(self, column, value)",
        "doc": "Return the row indices of a specified value ('value') in a specified column ('column'). All row indices where the value appears will be returned in a list.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.\n\nvalue (integer, float, string): the value to search for. All indices of the target value will be returned.",
        "example": "result = table.row_indices_of_val(column, value)"
    },
    "row_stat": {
        "name": "row_stat",
        "category": "Table",
        "signature": "(self, row, stat, decimals=2)",
        "doc": "Calculate and return the specified descriptive statistic ('stat') of the specified row ('row'). Only numeric values (integer or float) in the specified row will be included in the calculation.\n\nParameters:\n\nrow (integer): the index of the row the operation will be performed on.\n\nstat (string): the specific statistic to return. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.row_stat(row, stat, decimals=2)"
    },
    "row_stat_list": {
        "name": "row_stat_list",
        "category": "Table",
        "signature": "(self, stat, decimals=2)",
        "doc": "Calculate the specified descriptive statistic ('stat') of each row in the Table and return a list of statistics. Only numeric values (integer or float) in each row will be included in the calculation.\n\nParameters:\n\nstat (string): the specific statistic to calculate for each row. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = table.row_stat_list(stat, decimals=2)"
    },
    "scatter_plot": {
        "name": "scatter_plot",
        "category": "Table",
        "signature": "(self, x_col, y_cols, title='Scatter Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, point_size=3, point_colour=None, point_style=None, trendline=False, trend_colour=None, legend=False, point_labels=None, tooltip_threshold=100, margin=60, filename='scatter_plot.html', open_browser=False)",
        "doc": "Create a scatter plot for a single independent variable ('x_col') column and one or more dependent variables ('y_cols') and configure plot elements.\n\nParameters:\n\nx_col (integer, string): the index or header of the column representing the independent variable to be visualized. Values may be numerical (integer or floating point) or categorical strings such as dates.\n\ny_cols (integer, string, list): the index or header of a single column representing the dependent variable to be visualized, or a list of columns indices or headers if there are multiple dependent variables to be visualized. Values must be numerical (integer or floating point).\n\ntitle (string): the title of the scatter plot. \n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis. \n\nnum_ticks (integer): the number of tick marks to draw on each axis.\n\npoint_size (integer): the radius of points on the plot (in pixels).\n\npoint_colour (string, list): if a single dependent variable is given, this should be a single string representing the colour of the points. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each variable. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\npoint_style (string, list): the shape of points. May be specified as \"circle\", \"diamond\", \"square\", or \"triangle\". If a single dependent variable is given, this should be a single string representing the style of the points. If multiple dependent variables are given, this should be a list of strings corresponding to the style of each variable. If no styles are specified or the number of specified styles does not equal the number of dependent variables, random styles will be generated.\n\ntrendline (Boolean): flag to indicate if trend lines for each dependent variable will be calculated and displayed.\n\ntrend_colour (string, list): if a single dependent variable is given, this should be a single string representing the colour of the trend line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each trend line. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\npoint_labels (string, list): if a single dependent variable is given, this should be a single string representing the label of the points. If multiple dependent variables are given, this should be a list of strings representing the labels of each variable. If no labels are given, generic labels will be generated. A legend must be created to view point labels.\n\ntooltip_threshold (integer): the maximum number of points per series for which explicit hover-based tooltips are included.\n\nmargin (integer): the margin size (in pixels) around the plot area. \n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "table.scatter_plot(x_col, y_cols, title='Scatter Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, point_size=3, point_colour=None, point_style=None, trendline=False, trend_colour=None, legend=False, point_labels=None, tooltip_threshold=100, margin=60, filename='scatter_plot.html', open_browser=False)"
    },
    "set_data": {
        "name": "set_data",
        "category": "Table",
        "signature": "(self, rows)",
        "doc": "Set the Table object data to a nested list of rows.\n\nParameters: \n\nrows (list): the list of rows.",
        "example": "table.set_data(rows)"
    },
    "set_dtypes": {
        "name": "set_dtypes",
        "category": "Table",
        "signature": "(self, dtypes)",
        "doc": "Set the data type for each column. Column values will be converted to the specified data type.\n\nParameters:\n\ndtypes (list): a list of data type strings for each column. Can be specified as \"integer\" for integer data, \"float\" for float data, \"string\" for string data, or \"bool\" for Boolean data.",
        "example": "table.set_dtypes(dtypes)"
    },
    "set_headers": {
        "name": "set_headers",
        "category": "Table",
        "signature": "(self, new_headers)",
        "doc": "Insert new column headers ('new_headers') for all columns. If column headers already exist, this method replaces the existing headers. Headers may be defined for an empty Table.\n\nParameters:\n\nnew_headers (list): a list of the new headers for each column. If headers are not strings, they will be converted to strings.",
        "example": "table.set_headers(new_headers)"
    },
    "set_value": {
        "name": "set_value",
        "category": "Table",
        "signature": "(self, row, column, new_val)",
        "doc": "Replace an existing value at a specific position in the data with a new value ('new_val').\n\nParameters:\n\nrow (integer): the index of the row of the value to be modified.\n\ncolumn (integer, string): the index or header of the column of the value to be modified.\n\nnew_val (integer,float,string): the new value to replace the existing value at the given position.",
        "example": "table.set_value(row, column, new_val)"
    },
    "shift_column": {
        "name": "shift_column",
        "category": "Table",
        "signature": "(self, column, new_index)",
        "doc": "Move a specified column from its current position in the data to a new position as specified by an index ('new_index').\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to be moved.\n\nnew_index (integer): the index of the new position for the specified column.",
        "example": "table.shift_column(column, new_index)"
    },
    "shift_columns": {
        "name": "shift_columns",
        "category": "Table",
        "signature": "(self, columns, new_index)",
        "doc": "Move multiple specified columns from their current positions in the data to a new position as specified by an index ('new_index').\n\nParameters:\n\ncolumns (list): a list of indices of the columns to be moved.\n\nnew_index (integer): the index of the new position for the columns. If equal to the number of columns, the columns will be moved to the end.",
        "example": "table.shift_columns(columns, new_index)"
    },
    "shift_row": {
        "name": "shift_row",
        "category": "Table",
        "signature": "(self, row, new_index)",
        "doc": "Move a specified row from its current position in the data to a new position as specified by an index ('new_index').\n\nParameters:\n\nrow (integer): the index of the row to be moved.\n\nnew_index (integer): the index of the new position for the row.",
        "example": "table.shift_row(row, new_index)"
    },
    "shift_rows": {
        "name": "shift_rows",
        "category": "Table",
        "signature": "(self, rows, new_index)",
        "doc": "Move multiple specified rows from their current positions in the data to a new position as specified by an index ('new_index').\n\nParameters:\n\nrows (list): a list of indices of the rows to be moved.\n\nnew_index (integer): the index of the new position for the rows. If equal to the number of rows,the rows will be moved to the end.",
        "example": "table.shift_rows(rows, new_index)"
    },
    "sort_columns": {
        "name": "sort_columns",
        "category": "Table",
        "signature": "(self, method)",
        "doc": "Sort all columns in the Table by their headers using the specified method ('method') and return a new Table.\n\nParameters:\n\nmethod (string): the method to sort by. Can be specified as \"ascending\", \"asc\", \"low\" or \"descending\", \"desc\", \"high\".",
        "example": "result = table.sort_columns(method)"
    },
    "sort_rows": {
        "name": "sort_rows",
        "category": "Table",
        "signature": "(self, column, method)",
        "doc": "Sort all rows in the Table by a specified column ('column') and method ('method') and return a new Table.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to sort columns by.\n\nmethod (string): the method to sort by. Can be specified as \"ascending\", \"asc\", \"low\" or \"descending\", \"desc\", \"high\".",
        "example": "result = table.sort_rows(column, method)"
    },
    "split_table": {
        "name": "split_table",
        "category": "Table",
        "signature": "(self, num_tables)",
        "doc": "Split a Table into a specified number ('num_tables') of Table objects. Resulting Tables will have approximately equal numbers of rows, and will have the same headers and data types.\n\nParameters:\n\nnum_tables (integer): the number of Tables to split this Table into. Depending on the number of rows in the Table to be split, the actual number of split Tables may be one greater or lesser than the desired number.",
        "example": "result = table.split_table(num_tables)"
    },
    "swap_columns": {
        "name": "swap_columns",
        "category": "Table",
        "signature": "(self, col1, col2)",
        "doc": "Swap the positions of two specified columns in the data.\n\nParameters:\n\ncol1 (integer, string): the index or header of the first column to be swapped.\n\ncol2 (integer, string): the index or header of the second column to be swapped.",
        "example": "table.swap_columns(col1, col2)"
    },
    "swap_rows": {
        "name": "swap_rows",
        "category": "Table",
        "signature": "(self, row1, row2)",
        "doc": "Swap the positions of two specified rows in the data.\n\nParameters:\n\nrow1 (integer): the index of the first row to be swapped.\n\nrow2 (integer): the index of the second row to be swapped.",
        "example": "table.swap_rows(row1, row2)"
    },
    "transpose": {
        "name": "transpose",
        "category": "Table",
        "signature": "(self)",
        "doc": "Transpose the data, flipping rows and columns and return a new Table.",
        "example": "result = table.transpose()"
    },
    "transpose_with_headers": {
        "name": "transpose_with_headers",
        "category": "Table",
        "signature": "(self)",
        "doc": "Transpose the data, flipping rows and columns, and include the original headers as the first column of the new table and return a new Table.",
        "example": "result = table.transpose_with_headers()"
    },
    "unique_vals_in_col": {
        "name": "unique_vals_in_col",
        "category": "Table",
        "signature": "(self, column)",
        "doc": "Return a list of unique values in the specified column.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column the operation will be performed on.",
        "example": "result = table.unique_vals_in_col(column)"
    },
    "unique_vals_in_row": {
        "name": "unique_vals_in_row",
        "category": "Table",
        "signature": "(self, row)",
        "doc": "Return a list of unique values in the specified row.\n\nParameters:\n\nrow (integer): the row the operation will be performed on.",
        "example": "result = table.unique_vals_in_row(row)"
    },
    "unpivot": {
        "name": "unpivot",
        "category": "Table",
        "signature": "(self, id_vars, value_vars, var_name='Variable', value_name='Value')",
        "doc": "Unpivot the table from wide to long format and return a new Table.\n\nParameters:\n\nid_vars (list): list of indices or headers to keep as identifier columns.\n\nvalue_vars (list): list of indices or headers to melt into rows.\n\nvar_name (string): the header name for the new variable column.\n\nvalue_name (string): the header name for the new value column.",
        "example": "result = table.unpivot(id_vars, value_vars, var_name='Variable', value_name='Value')"
    },
    "value_in_column": {
        "name": "value_in_column",
        "category": "Table",
        "signature": "(self, column, value)",
        "doc": "Determine if the specified value ('value') exists in the specified column ('column'). Returns True or False.\n\nParameters:\n\ncolumn (integer, string): the index or header of the column to check for the specified value.\n\nvalue (integer, float, string): the value to check for.",
        "example": "result = table.value_in_column(column, value)"
    },
    "value_in_row": {
        "name": "value_in_row",
        "category": "Table",
        "signature": "(self, row, value)",
        "doc": "Determine if the specified value ('value') exists in the specified row ('row'). Returns True or False.\n\nParameters:\n\nrow (integer): the row to check for the specified value.\n\nvalue (integer, float, string): the value to check for.",
        "example": "result = table.value_in_row(row, value)"
    },
    "conversion": {
        "name": "conversion",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing unit conversions on lists of numerical values.",
        "functions": [
            "convert_area",
            "convert_concentration",
            "convert_density",
            "convert_distance",
            "convert_energy",
            "convert_flowrate",
            "convert_force",
            "convert_power",
            "convert_pressure",
            "convert_temperature",
            "convert_time",
            "convert_velocity",
            "convert_volume",
            "convert_weight",
            "display_toolbox_functions"
        ],
        "example": "result = tt.conversion.convert_area(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_area": {
        "name": "convert_area",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of area ('from_unit') to another unit of area ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"cm\" for centimeters squared, \"m\" for meters squared, \"km\" for kilometers squared, \"ha\" for hectares, \"ft\" for feet squared, \"mi\" for miles squared, and \"ac\" for acres.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"cm\" for centimeters squared, \"m\" for meters squared, \"km\" for kilometers squared, \"ha\" for hectares, \"ft\" for feet squared, \"mi\" for miles squared, and \"ac\" for acres.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_area(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_concentration": {
        "name": "convert_concentration",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of concentration ('from_unit') to another unit of concentration ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"mg/L\" for milligrams per liter, \"g/L\" for grams per liter, \"ppm\" for parts per million, and \"%\" for percent by mass/volume (assuming dilute aqueous solutions).\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"mg/L\" for milligrams per liter, \"g/L\" for grams per liter, \"ppm\" for parts per million, and \"%\" for percent by mass/volume (assuming dilute aqueous solutions).\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_concentration(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_density": {
        "name": "convert_density",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of density ('from_unit') to another unit of density ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"kg/m3\" for kilograms per cubic meter, \"g/cm3\" for grams per cubic centimeter, and \"lb/ft3\" for pounds per cubic foot.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"kg/m3\" for kilograms per cubic meter, \"g/cm3\" for grams per cubic centimeter, and \"lb/ft3\" for pounds per cubic foot.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_density(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_distance": {
        "name": "convert_distance",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of distance ('from_unit') to another unit of distance ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"mm\" for millimeters, \"cm\" for centimeters, \"m\" for meters, \"km\" for kilometers, \"in\" for inches, \"ft\" for feet, \"yd\" for yards, and \"mi\" for miles.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"mm\" for millimeters, \"cm\" for centimeters, \"m\" for meters, \"km\" for kilometers, \"in\" for inches, \"ft\" for feet, \"yd\" for yards, and \"mi\" for miles.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_distance(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_energy": {
        "name": "convert_energy",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of energy ('from_unit') to another unit of energy ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"J\" for joules, \"kJ\" for kilojoules, \"cal\" for calories, \"kcal\" for kilocalories, \"Wh\" for watt-hours, \"kWh\" for kilowatt-hours, and \"BTU\" for British thermal units.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"J\" for joules, \"kJ\" for kilojoules, \"cal\" for calories, \"kcal\" for kilocalories, \"Wh\" for watt-hours, \"kWh\" for kilowatt-hours, and \"BTU\" for British thermal units.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_energy(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_flowrate": {
        "name": "convert_flowrate",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of flow rate ('from_unit') to another unit of flow rate ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"m3/s\" for cubic meters per second, \"L/s\" for liters per second, \"L/min\" for liters per minute, \"gal/min\" for US gallons per minute, and \"ft3/s\" for cubic feet per second.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"m3/s\" for cubic meters per second, \"L/s\" for liters per second, \"L/min\" for liters per minute, \"gal/min\" for US gallons per minute, and \"ft3/s\" for cubic feet per second.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_flowrate(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_force": {
        "name": "convert_force",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of force ('from_unit') to another unit of force ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"N\" for newtons, \"kN\" for kilonewtons, \"dyn\" for dynes, and \"lbf\" for pounds-force.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"N\" for newtons, \"kN\" for kilonewtons, \"dyn\" for dynes, and \"lbf\" for pounds-force.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_force(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_power": {
        "name": "convert_power",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of power ('from_unit') to another unit of power ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"W\" for watts, \"kW\" for kilowatts, \"MW\" for megawatts, and \"hp\" for horsepower.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"W\" for watts, \"kW\" for kilowatts, \"MW\" for megawatts, and \"hp\" for horsepower.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_power(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_pressure": {
        "name": "convert_pressure",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of pressure ('from_unit') to another unit of pressure ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"Pa\" for pascals, \"kPa\" for kilopascals, \"bar\" for bars, \"atm\" for atmospheres, \"psi\" for pounds per square inch, and \"mmHg\" for millimeters of mercury.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"Pa\" for pascals, \"kPa\" for kilopascals, \"bar\" for bars, \"atm\" for atmospheres, \"psi\" for pounds per square inch, and \"mmHg\" for millimeters of mercury.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_pressure(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_temperature": {
        "name": "convert_temperature",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of temperature ('from_unit') to another unit of temperature ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"k\" for kelvin, \"c\" for celsius, and \"f\" for fahrenheit.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"k\" for kelvin, \"c\" for celsius, and \"f\" for fahrenheit.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_temperature(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_time": {
        "name": "convert_time",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of time ('from_unit') to another unit of time ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"ms\" for milliseconds, \"s\" for seconds, \"m\" for minutes, \"hr\" for hours, \"d\" for days, and \"y\" for years.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"ms\" for milliseconds, \"s\" for seconds, \"m\" for minutes, \"hr\" for hours, \"d\" for days, and \"y\" for years.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_time(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_velocity": {
        "name": "convert_velocity",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of velocity ('from_unit') to another unit of velocity ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"m/s\" for meters per second, \"km/h\" for kilometers per hour, \"mph\" for miles per hour, \"ft/s\" for feet per second, and \"kn\" for knots.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"m/s\" for meters per second, \"km/h\" for kilometers per hour, \"mph\" for miles per hour, \"ft/s\" for feet per second, and \"kn\" for knots.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_velocity(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_volume": {
        "name": "convert_volume",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of volume ('from_unit') to another unit of volume ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"ml\" for millilitres, \"l\" for litres, \"mm\" for cubic millimeters, \"cm\" for cubic centimeters, \"m\" for cubic meters, \"in\" for cubic inches, \"ft\" for cubic feet, \"oz\" for fluid ounces, and \"gal\" for gallons.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"ml\" for millilitres, \"l\" for litres, \"mm\" for cubic millimeters, \"cm\" for cubic centimeters, \"m\" for cubic meters, \"in\" for cubic inches, \"ft\" for cubic feet, \"oz\" for fluid ounces, and \"gal\" for gallons.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_volume(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.convert_weight": {
        "name": "convert_weight",
        "category": "conversion",
        "signature": "(self, vals, from_unit, to_unit, decimals=2)",
        "doc": "Convert the values of the input list ('vals') from their current unit of weight ('from_unit') to another unit of weight ('to_unit') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfrom_unit (string): the unit the list of values is being converted from. Possible values include \"mg\" for milligrams, \"g\" for grams, \"kg\" for kilograms, \"t\" for metric tonnes, \"oz\" for ounces, \"lb\" for pounds, \"st\" for imperial short tons, and \"lt\" for imperial long tons.\n\nto_unit (string): the unit the list of values is being converted to. Possible values include \"mg\" for milligrams, \"g\" for grams, \"kg\" for kilograms, \"t\" for metric tonnes, \"oz\" for ounces, \"lb\" for pounds, \"st\" for imperial short tons, and \"lt\" for imperial long tons.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.conversion.convert_weight(vals, from_unit, to_unit, decimals=2)"
    },
    "conversion.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "conversion",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.conversion.display_toolbox_functions()"
    },
    "date": {
        "name": "date",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing operations on lists of dates or lists of numerical values using a corresponding list of dates.",
        "functions": [
            "aggregate_day",
            "aggregate_month",
            "aggregate_season",
            "aggregate_year",
            "aggregate_year_single",
            "check_date_continuity",
            "date_range_intersection",
            "date_range_slice",
            "date_to_iso",
            "display_toolbox_functions",
            "extend_dates",
            "find_missing_dates",
            "generate_day_range",
            "generate_day_range_alt",
            "generate_day_range_doy",
            "generate_day_range_julian",
            "generate_leap_years",
            "generate_month_range",
            "generate_year_range",
            "get_date_range",
            "get_days",
            "get_months",
            "get_years",
            "group_by_day",
            "group_by_month",
            "group_by_season",
            "group_by_year",
            "group_year_single",
            "insert_missing_date_values",
            "is_leap_year",
            "normalize_dates",
            "optimal_overlap_range",
            "threshold_date",
            "validate_dates"
        ],
        "example": "result = tt.date.aggregate_day(dates, vals, method)"
    },
    "date.aggregate_day": {
        "name": "aggregate_day",
        "category": "date",
        "signature": "(self, dates, vals, method)",
        "doc": "Aggregate the values of an input list ('vals') by day using a corresponding list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmethod (string): the method used to aggregate the data. Possible aggregation methods are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Skewness\", and \"Kurtosis\" ",
        "example": "result = tt.date.aggregate_day(dates, vals, method)"
    },
    "date.aggregate_month": {
        "name": "aggregate_month",
        "category": "date",
        "signature": "(self, dates, vals, method)",
        "doc": "Aggregate the values of an input list ('vals') by month using a corresponding list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmethod (string): the method used to aggregate the data. Possible aggregation methods are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Skewness\", and \"Kurtosis\" ",
        "example": "result = tt.date.aggregate_month(dates, vals, method)"
    },
    "date.aggregate_season": {
        "name": "aggregate_season",
        "category": "date",
        "signature": "(self, dates, vals, months, method)",
        "doc": "Aggregate the values of an input list ('vals') by a specified season ('months') using a corresponding list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmonths (list): a list of integers corresponding to the months within a particular season. For example, if aggregating within the winter season, [1,2,12] would correspond to the months of January, February, and December, respectively. Month values should be given in ascending order.\n\nmethod (string): the method used to aggregate the data. Possible aggregation methods are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Skewness\", and \"Kurtosis\" ",
        "example": "result = tt.date.aggregate_season(dates, vals, months, method)"
    },
    "date.aggregate_year": {
        "name": "aggregate_year",
        "category": "date",
        "signature": "(self, dates, vals, method)",
        "doc": "Aggregate the values of an input list ('vals') by year using a corresponding list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmethod (string): the method used to aggregate the data. Possible aggregation methods are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Skewness\", and \"Kurtosis\" ",
        "example": "result = tt.date.aggregate_year(dates, vals, method)"
    },
    "date.aggregate_year_single": {
        "name": "aggregate_year_single",
        "category": "date",
        "signature": "(self, dates, vals, year, method)",
        "doc": "Aggregate the values of an input list ('vals') for a single specified year ('year') using a corresponding list of dates ('dates') and return the aggregated value.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nyear (integer): the single year of data to aggregate. Must be in a 'yyyy' format.\n\nmethod (string): the method used to aggregate the data. Possible aggregation methods are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Skewness\", and \"Kurtosis\" ",
        "example": "result = tt.date.aggregate_year_single(dates, vals, year, method)"
    },
    "date.check_date_continuity": {
        "name": "check_date_continuity",
        "category": "date",
        "signature": "(self, dates)",
        "doc": "Check whether a list of dates ('dates') forms a continuous, gap-free daily sequence from the earliest date to the latest date and return True or False.\n\nParameters:\n\ndates (list): the list of dates the operation will be performed on. The input list will not be altered by the operation. Any character may be used as a separator for string dates. The input list will not be altered by the operation.",
        "example": "result = tt.date.check_date_continuity(dates)"
    },
    "date.date_range_intersection": {
        "name": "date_range_intersection",
        "category": "date",
        "signature": "(self, range1, range2)",
        "doc": "Determine if two input date ranges ('range1','range2') overlap and return the start and end dates of the overlapping range. It is assumed that the date ranges are sorted in order. Returns a tuple of (start, end). If there is no overlap between date ranges, a tuple of (None, None) is returned.\n\nParameters:\n\nrange1 (list): the first list of dates the operation will be performed on. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts. The input list will not be altered by the operation.\n\nrange1 (list): the second list of dates the operation will be performed on. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts. The input list will not be altered by the operation.",
        "example": "result = tt.date.date_range_intersection(range1, range2)"
    },
    "date.date_range_slice": {
        "name": "date_range_slice",
        "category": "date",
        "signature": "(self, dates, vals, start, end)",
        "doc": "Return a subset of values from an input list ('vals') within a specified date range using a corresponding list of dates ('dates').\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nstart (string): the starting date in the output range of values. The string \"start\" may be specified to indicate the start of the date range, otherwise it must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.\n\nend (string): the ending date in the output range of values. This date is non-inclusive (eg. if an ending date of 2020-01-01 is specified, the last day in the output date range will be 2019-12-31). The string \"end\" may be specified to indicate the end of the date range, otherwise it must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.",
        "example": "result = tt.date.date_range_slice(dates, vals, start, end)"
    },
    "date.date_to_iso": {
        "name": "date_to_iso",
        "category": "date",
        "signature": "(self, dates, formats)",
        "doc": "Convert a specified column ('dates') to ISO format (yyyy-mm-dd). Dates that do not match the specified formats ('formats') will be returned unaltered.\n\nParameters:\n\ndates (list): the list of dates the operation will be performed on. The input list will not be altered by the operation.\n\nformats (string, list): a string or list of strings of date formats to attempt to convert to ISO format.",
        "example": "result = tt.date.date_to_iso(dates, formats)"
    },
    "date.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "date",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.date.display_toolbox_functions()"
    },
    "date.extend_dates": {
        "name": "extend_dates",
        "category": "date",
        "signature": "(self, dates, num_days)",
        "doc": "Extend the input list of dates ('dates') by a specified number of days ('num_days') and return a new list of dates.\n\nParameters:\n\ndates (list): the list of dates the operation will be performed on. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts. The input list will not be altered by the operation.\n\nnum_days (integer): the number of days to extend the list of dates by.",
        "example": "result = tt.date.extend_dates(dates, num_days)"
    },
    "date.find_missing_dates": {
        "name": "find_missing_dates",
        "category": "date",
        "signature": "(self, dates)",
        "doc": "Return a sorted list of missing dates within the range defined by the earliest and latest dates in the input list ('dates').\n\nParameters:\n\ndates (list): the list of dates the operation will be performed on. All dates must be ISO-style strings ('yyyy-mm-dd'). The input list will not be altered by the operation.",
        "example": "result = tt.date.find_missing_dates(dates)"
    },
    "date.generate_day_range": {
        "name": "generate_day_range",
        "category": "date",
        "signature": "(self, start, end)",
        "doc": "Return a list of daily dates in a yyyy-mm-dd format within the specified range, with years starting on January 1 (01-01).\n\nParameters:\n\nstart (string): the starting date in the date range. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts, but separators must be the same between start and end dates.\n\nend (string): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020-01-01 is specified, the last day in the output date range will be 2019-12-31). Must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.",
        "example": "result = tt.date.generate_day_range(start, end)"
    },
    "date.generate_day_range_alt": {
        "name": "generate_day_range_alt",
        "category": "date",
        "signature": "(self, start, end, month)",
        "doc": "Return a list of daily dates in a yyyy-mm-dd format within the specified range, where the years start at an alternative month (i.e. not January (01)). This function could be used to generate dates by hydrological year (October to September), for example.\n\nParameters:\n\nstart (string): the starting date in the date range. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts.\n\nend (string): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020-01-01 is specified, the last day in the output date range will be 2019-12-31). Must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.\n\nmonth (integer): the integer corresponding to the month each year will begin at. Must be greater than 1 (January) and less than or equal to 12 (December).",
        "example": "result = tt.date.generate_day_range_alt(start, end, month)"
    },
    "date.generate_day_range_doy": {
        "name": "generate_day_range_doy",
        "category": "date",
        "signature": "(self, start, end)",
        "doc": "Return a list of daily dates in a day-of-year format within the specified range.\n\nParameters:\n\nstart (string): the starting date in the date range. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts, but separators must be the same between start and end dates.\n\nend (string): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020-01-01 is specified, the last day in the output date range will be 2019-12-31). Must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.",
        "example": "result = tt.date.generate_day_range_doy(start, end)"
    },
    "date.generate_day_range_julian": {
        "name": "generate_day_range_julian",
        "category": "date",
        "signature": "(self, start, end)",
        "doc": "Return a list of daily dates in a Julian format within the specified range, with years starting on January 1 (001).\n\nParameters:\n\nstart (string): the starting date in the date range. Must be in a \"yyyy-mm-dd\" format. Any character may be used to separate date parts.\n\nend (string): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020-01-01 is specified, the last day in the output date range will be 2019-12-31 (2019365)). Must be in a \"yyyy-mm-dd\" format. A hyphen \"-\", forward slash \"/\", or space \" \" may be used to separate date parts.",
        "example": "result = tt.date.generate_day_range_julian(start, end)"
    },
    "date.generate_leap_years": {
        "name": "generate_leap_years",
        "category": "date",
        "signature": "(self, start, end)",
        "doc": "Return a list of leap years in a yyyy format within the specified range.\n\nParameters:\n\nstart (integer): the starting date in the date range. Must be in a yyyy format.\n\nend (integer): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020 is specified, the last year in the output date range will be 2019). Must be in a yyyy format.",
        "example": "result = tt.date.generate_leap_years(start, end)"
    },
    "date.generate_month_range": {
        "name": "generate_month_range",
        "category": "date",
        "signature": "(self, start=1, length=12, form='numeric')",
        "doc": "Return a list of months of the specified length ('length') and the specified format ('format').\n\nParameters:\n\nstart (integer): the integer corresponding to the starting month in the month range. Should be greater than or equal to 1 (January) and less than or equal to 12 (December)\n\nlength (integer): the number of months in the output range.\n\nform (string): the format of months in the output list. May be specified as \"numeric\" for integer format (1,2,3...), \"padded numeric\" for integers as zero-padded strings (\"01\",\"02\",\"03\"...), \"full text\" for full month names (\"January\",\"February\",\"March\"...) or \"short text\" for shortened month names (\"Jan\",\"Feb\",\"Mar\"...).",
        "example": "result = tt.date.generate_month_range(start=1, length=12, form='numeric')"
    },
    "date.generate_year_range": {
        "name": "generate_year_range",
        "category": "date",
        "signature": "(self, start, end)",
        "doc": "Return a list of yearly dates in a yyyy format within the specified range.\n\nParameters:\n\nstart (integer, string): the starting date in the date range. May be specified as an integer in yyyy format or an ISO format date string.\n\nend (integer ,string): the ending date in the date range. This date is non-inclusive (eg. if an ending date of 2020 is specified, the last year in the output date range will be 2019). May be specified as an integer in yyyy format or an ISO format date string.",
        "example": "result = tt.date.generate_year_range(start, end)"
    },
    "date.get_date_range": {
        "name": "get_date_range",
        "category": "date",
        "signature": "(self, vals)",
        "doc": "Return a tuple of (start date, end date) from the input list ('vals') of dates.\n\nParameters:\n\nvals (list): the list of dates the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.date.get_date_range(vals)"
    },
    "date.get_days": {
        "name": "get_days",
        "category": "date",
        "signature": "(self, vals, dtype='integer')",
        "doc": "Separate the days from each date in an input list of dates ('vals') and return a new list of days.\n\nParameters:\n\nvals (list): the list of dates the operation will be performed on. The input list will not be altered by the operation. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts.\n\ndtype (string): the data type of the output days. May be specified as \"integer\" or \"string\" for integer or string representations of days, respectively.",
        "example": "result = tt.date.get_days(vals, dtype='integer')"
    },
    "date.get_months": {
        "name": "get_months",
        "category": "date",
        "signature": "(self, vals, dtype='integer')",
        "doc": "Separate the months from each date in an input list of dates ('vals') and return a new list of months.\n\nParameters:\n\nvals (list): the list of dates the operation will be performed on. The input list will not be altered by the operation. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts.\n\ndtype (string): the data type of the output months. May be specified as \"integer\" or \"string\" for integer or string representations of months, respectively.",
        "example": "result = tt.date.get_months(vals, dtype='integer')"
    },
    "date.get_years": {
        "name": "get_years",
        "category": "date",
        "signature": "(self, vals, dtype='integer')",
        "doc": "Separate the years from each date in an input list of dates ('vals') and return a new list of years.\n\nParameters:\n\nvals (list): the list of dates the operation will be performed on. The input list will not be altered by the operation. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts.\n\ndtype (string): the data type of the output years. May be specified as \"integer\" or \"string\" for integer or string representations of years, respectively.",
        "example": "result = tt.date.get_years(vals, dtype='integer')"
    },
    "date.group_by_day": {
        "name": "group_by_day",
        "category": "date",
        "signature": "(self, dates, vals)",
        "doc": "Group the values from an input list ('vals') using a corresponding list of dates ('dates') into lists of values within each day in the date range and return a nested list of daily sublists.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.date.group_by_day(dates, vals)"
    },
    "date.group_by_month": {
        "name": "group_by_month",
        "category": "date",
        "signature": "(self, dates, vals)",
        "doc": "Group the values from an input list ('vals') using a corresponding list of dates ('dates') into lists of values within each month in the date range and return a nested list of monthly sublists.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.date.group_by_month(dates, vals)"
    },
    "date.group_by_season": {
        "name": "group_by_season",
        "category": "date",
        "signature": "(self, dates, vals, months)",
        "doc": "Group the values from an input list ('vals') using a corresponding list of dates ('dates') into lists of values within the specified season ('months') in the date range and return a nested list of season sublists.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmonths (list): a list of integers corresponding to the months within a particular season. For example, if grouping by the winter season, [1,2,12] would correspond to the months of January, February, and December, respectively. Month values should be given in ascending order.",
        "example": "result = tt.date.group_by_season(dates, vals, months)"
    },
    "date.group_by_year": {
        "name": "group_by_year",
        "category": "date",
        "signature": "(self, dates, vals)",
        "doc": "Group the values from an input list ('vals') using a corresponding list of dates ('dates') into lists of values within each year in the date range and return a nested list of yearly sublists.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.date.group_by_year(dates, vals)"
    },
    "date.group_year_single": {
        "name": "group_year_single",
        "category": "date",
        "signature": "(self, dates, vals, year)",
        "doc": "Group the values of an input list ('vals') for a single specified year ('year') using a corresponding list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nyear (integer): the single year of data to group. Must be in a 'yyyy' format.",
        "example": "result = tt.date.group_year_single(dates, vals, year)"
    },
    "date.insert_missing_date_values": {
        "name": "insert_missing_date_values",
        "category": "date",
        "signature": "(self, dates, vals, placeholder='')",
        "doc": "Insert placeholder values into a list of values ('vals') wherever dates are missing from the list of dates ('dates'). Returns both the new date list and a new value list with placeholders inserted.\n\nParameters:\n\ndates (list): the list of ISO-style dates ('yyyy-mm-dd') the operation will be performed on. The input list will not be altered.\n\nvals (list): the list of values corresponding to each date. Must be the same length as 'dates'.\n\nplaceholder: the value to insert for missing dates. Default is \"\".",
        "example": "result = tt.date.insert_missing_date_values(dates, vals, placeholder='')"
    },
    "date.is_leap_year": {
        "name": "is_leap_year",
        "category": "date",
        "signature": "(self, year)",
        "doc": "Determine if the specified year is a leap year. Returns True or False.\n\nParameters:\n\nyear (integer, string): the year the operation will be performed on.",
        "example": "result = tt.date.is_leap_year(year)"
    },
    "date.normalize_dates": {
        "name": "normalize_dates",
        "category": "date",
        "signature": "(self, dates, sep='-')",
        "doc": "Normalize separators in a list of dates ('dates') to a consistent ISO-style format and return a list of dates.\n\nParameters:\n\ndates (list): the list of dates to normalize. Any character may be used to separate date parts. If a date contains no separators but is in 'yyyymmdd' format, separators will be added automatically.\n\nsep (string): the separator to use in the normalized output. Default is '-'.",
        "example": "result = tt.date.normalize_dates(dates, sep='-')"
    },
    "date.optimal_overlap_range": {
        "name": "optimal_overlap_range",
        "category": "date",
        "signature": "(self, date_ranges, tolerance=0.05)",
        "doc": "Determine the 'optimal' overlapping date range across many input date ranges ('dates') by evaluating all combinations of start and end dates from the input dates and assigning a score based on number of overlapping date ranges and the total days captured by each combination. Optimal is defined as the start and end date that maximizes the number of input ranges that overlap within the given tolerance of days while favouring longer shared durations. Returns a dictionary of \"best_start\" (i.e., optimal start date), \"best_end\" (i.e., optimal end date), \"count\" (i.e, the number of input date ranges that overlap the optimal range within the tolerance), \"percent\" (i.e, the percentage of input date ranges that overlap the optimal range within the tolerance), and \"days\" (i.e., the number of days in the optimal date range). \n\nParameters:\n\ndate_sequences (list): a nested list of date range lists. Individual dates must be in ISO format (i.e., yyyy-mm-dd)\n    \ntolerance (float): the tolerance threshold for required overlap as a percent of shared days between date ranges.",
        "example": "result = tt.date.optimal_overlap_range(date_ranges, tolerance=0.05)"
    },
    "date.threshold_date": {
        "name": "threshold_date",
        "category": "date",
        "signature": "(self, dates, condition, threshold)",
        "doc": "Apply a date threshold ('threshold') to a list of dates ('dates') and return a new list.\n\nParameters:\n\ndates (list): the list of dates used to aggregate the input list of values. List of dates must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts. List of dates must be the same length as the list of values. It is expected that dates are ordered sequentially.\n\ncondition (string): the condition placed upon each date in the input list. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.\n\nthreshold (string): the threshold to evaluate each date in the input list against. Must be in \"yyyy-mm-dd\" format.",
        "example": "result = tt.date.threshold_date(dates, condition, threshold)"
    },
    "date.validate_dates": {
        "name": "validate_dates",
        "category": "date",
        "signature": "(self, dates, raise_errors=True)",
        "doc": "Validate that all items in a list of dates ('dates') are properly formatted ISO-style date strings. Can return either a Boolean or raise errors.\n\nParameters:\n\ndates (list): the list of dates to validate. Each date must be in a 'yyyy-mm-dd' format. Any character may be used to separate date parts.\n\nraise_errors (bool): flag to indicate whether to raise detailed ValueError messages when invalid dates are encountered (default True). If False, the function will return True/False instead.",
        "example": "result = tt.date.validate_dates(dates, raise_errors=True)"
    },
    "generate": {
        "name": "generate",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for generating new lists of different data types and distributions.",
        "functions": [
            "arithmetic_seq",
            "beta",
            "binomial",
            "constant",
            "display_toolbox_functions",
            "exponential",
            "fibonacci_seq",
            "gamma",
            "gaussian",
            "geometric_seq",
            "harmonic_seq",
            "lognormal",
            "pareto",
            "points_in_grid",
            "poisson",
            "prime_seq",
            "rand_boolean",
            "rand_colours",
            "rand_floats",
            "rand_ints",
            "rand_points",
            "rand_strings",
            "rand_strings_user_defined",
            "triangular",
            "uniform",
            "varied_arithmetic_seq",
            "weibull"
        ],
        "example": "result = tt.generate.arithmetic_seq(start, step, length)"
    },
    "generate.arithmetic_seq": {
        "name": "arithmetic_seq",
        "category": "generate",
        "signature": "(self, start, step, length)",
        "doc": "Return a list of values of the specified length ('length') in which the specified difference between subsequent values ('step') is constant (by addition or subtraction).\n\nParameters:\n\nstart (integer, float): the first value of the output data range.\n\nstep (integer, float): the difference between subsequent values. May be positive (for addition) or negative (for subtraction).\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.arithmetic_seq(start, step, length)"
    },
    "generate.beta": {
        "name": "beta",
        "category": "generate",
        "signature": "(self, alpha, beta, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a beta distribution.\n\nParameters:\n\nalpha (integer, float): the alpha value of the output distribution. Must be greater than 0.\n\nbeta (integer, float): the beta value of the output distribution. Must be greater than 0.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.beta(alpha, beta, length, decimals=2)"
    },
    "generate.binomial": {
        "name": "binomial",
        "category": "generate",
        "signature": "(self, n, p, length)",
        "doc": "Return a list of values of the specified length ('length') to fit a binomial distribution.\n\nParameters:\n\nn (integer): the number of trials. Must be greater than 0.\n\np (float): the probability of success in each trial. Must be between 0 and 1.\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.binomial(n, p, length)"
    },
    "generate.constant": {
        "name": "constant",
        "category": "generate",
        "signature": "(self, val, length)",
        "doc": "Return a list of a single specified value ('val') of the specified length ('length').\n\nParameters:\n\nval (integer, float, string, list, object): the constant value or object of the output list.\n\nlength (integer): the number of values or objects in the output list.",
        "example": "result = tt.generate.constant(val, length)"
    },
    "generate.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "generate",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.generate.display_toolbox_functions()"
    },
    "generate.exponential": {
        "name": "exponential",
        "category": "generate",
        "signature": "(self, lmbda, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit an exponential distribution.\n\nParameters:\n\nlmbda (integer, float): the lambda value of the distribution. Must not be 0. The lambda value should be the reciprocal of the desired mean.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.exponential(lmbda, length, decimals=2)"
    },
    "generate.fibonacci_seq": {
        "name": "fibonacci_seq",
        "category": "generate",
        "signature": "(self, length)",
        "doc": "Return a list of the first ('length') Fibonacci numbers.\n\nParameters:\n\nlength (integer): the number of Fibonacci numbers in the output list.",
        "example": "result = tt.generate.fibonacci_seq(length)"
    },
    "generate.gamma": {
        "name": "gamma",
        "category": "generate",
        "signature": "(self, alpha, beta, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a gamma distribution.\n\nParameters:\n\nalpha (integer, float): the alpha value of the output distribution. Must be greater than 0.\n\nbeta (integer, float): the beta value of the output distribution. Must be greater than 0.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.gamma(alpha, beta, length, decimals=2)"
    },
    "generate.gaussian": {
        "name": "gaussian",
        "category": "generate",
        "signature": "(self, mean, sd, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a Gaussian distribution.\n\nParameters:\n\nmean (integer, float): the mean of the distribution.\n\nsd (integer, float): the standard deviation of the distribution.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.gaussian(mean, sd, length, decimals=2)"
    },
    "generate.geometric_seq": {
        "name": "geometric_seq",
        "category": "generate",
        "signature": "(self, start, step, length)",
        "doc": "Return a list of values of the specified length ('length') in which the specified difference between subsequent values ('step') is a ratio (by multiplication).\n\nParameters:\n\nstart (integer, float): the first value of the output data range.\n\nstep (integer, float): the difference between subsequent values. May be positive or negative.\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.geometric_seq(start, step, length)"
    },
    "generate.harmonic_seq": {
        "name": "harmonic_seq",
        "category": "generate",
        "signature": "(self, start, step, length)",
        "doc": "Return a list of values of the specified length ('length') in which the specified difference between subsequent values ('step') is the reciprocal of an arithmetic sequence.\n\nParameters:\n\nstart (integer, float): the first value of the output data range.\n\nstep (integer, float): the difference between subsequent values. May be positive (for addition) or negative (for subtraction).\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.harmonic_seq(start, step, length)"
    },
    "generate.lognormal": {
        "name": "lognormal",
        "category": "generate",
        "signature": "(self, mean, sd, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a log normal distribution.\n\nParameters:\n\nmean (integer, float): the mean of the distribution.\n\nsd (integer, float): the standard deviation of the distribution. Must be greater than 0.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.lognormal(mean, sd, length, decimals=2)"
    },
    "generate.pareto": {
        "name": "pareto",
        "category": "generate",
        "signature": "(self, alpha, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a Pareto distribution.\n\nParameters:\n\nalpha (integer, float): the alpha value (shape) of the output distribution.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.pareto(alpha, length, decimals=2)"
    },
    "generate.points_in_grid": {
        "name": "points_in_grid",
        "category": "generate",
        "signature": "(self, extent, dist, decimals=2)",
        "doc": "Return a PointDataset within the specified extent ('extent') in a grid pattern. The specified distance between points ('dist') and the extent determine how many points will be in the output PointDataset.\n\nParameters:\n\nextent (list, tuple): a list or tuple representing the minimum x, minimum y, maximum x, and maximum y, in that order, of the extent to generate points in. Points are generated from left to right and top to bottom within the extent.\n\ndist (integer, float): the x and y spacing between points. \n\ndecimals (integer): the maximum number of decimal points each coordinate can have.",
        "example": "result = tt.generate.points_in_grid(extent, dist, decimals=2)"
    },
    "generate.poisson": {
        "name": "poisson",
        "category": "generate",
        "signature": "(self, lam, length)",
        "doc": "Return a list of values of the specified length ('length') to fit a Poisson distribution.\n\nParameters:\n\nlam (float): the expected number of events (lambda). Must be greater than 0.\n\nlength (integer): the number of values in the output list. ",
        "example": "result = tt.generate.poisson(lam, length)"
    },
    "generate.prime_seq": {
        "name": "prime_seq",
        "category": "generate",
        "signature": "(self, length)",
        "doc": "Return a list of the first ('length') prime numbers.\n\nParameters:\n\nlength (integer): the number of prime numbers in the output list. ",
        "example": "result = tt.generate.prime_seq(length)"
    },
    "generate.rand_boolean": {
        "name": "rand_boolean",
        "category": "generate",
        "signature": "(self, length, numeric=True)",
        "doc": "Return a list of random Boolean values of the specified length ('length'), which may be either numeric (1 and 0) or not (True and False).\n\nParameters:\n\nlength (integer): the number of values in the output data range.\n\nnumeric (Boolean): flag to indicate if the output Boolean values will be represented numerically (1 and 0) or not (True and False).",
        "example": "result = tt.generate.rand_boolean(length, numeric=True)"
    },
    "generate.rand_colours": {
        "name": "rand_colours",
        "category": "generate",
        "signature": "(self, length, fmt='rgb')",
        "doc": "Return a list of the specified length ('length') of random colours of the specified colour space format ('fmt').\n\nParameters:\n\nlength (integer): the number of values in the output list.\n\nfmt (string): the colour space format of the output colours. May be specified as \"rgb\" for RGB (Red Green Blue), \"cmy\" for CMY (Cyan Magenta Yellow), \"hex\" for hex code, \"hsv\" for HSV (Hue Saturation Value), and \"hsl\" for HSL (Hue Saturation Lightness).",
        "example": "result = tt.generate.rand_colours(length, fmt='rgb')"
    },
    "generate.rand_floats": {
        "name": "rand_floats",
        "category": "generate",
        "signature": "(self, min_val, max_val, length, decimals=2)",
        "doc": "Return a list of random floating-point values of the specified length ('length') in the inclusive range specified by the minimum ('min_val') and maximum ('max_val') values.\n\nParameters:\n\nmin_val (integer): the minimum value of the output data range.\n\nmax_val (integer): the maximum value of the output data range.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the maximum number of decimal points each value can have.",
        "example": "result = tt.generate.rand_floats(min_val, max_val, length, decimals=2)"
    },
    "generate.rand_ints": {
        "name": "rand_ints",
        "category": "generate",
        "signature": "(self, min_val, max_val, length)",
        "doc": "Return a list of random integers of the specified length ('length') in the inclusive range specified by the minimum ('min_val') and maximum ('max_val') values.\n\nParameters:\n\nmin_val (integer): the minimum value of the output data range.\n\nmax_val (integer): the maximum value of the output data range.\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.rand_ints(min_val, max_val, length)"
    },
    "generate.rand_points": {
        "name": "rand_points",
        "category": "generate",
        "signature": "(self, extent, num_points, decimals=2)",
        "doc": "Return a PointDataset of the specified number of points ('num_points') within the specified extent ('extent').\n\nParameters:\n\nextent (list, tuple): a list or tuple representing the minimum x, minimum y, maximum x, and maximum y, in that order, of the extent to generate points in. \n\nnum_points (integer): the number of points in the output PointDataset.\n\ndecimals (integer): the maximum number of decimal points each coordinate can have.",
        "example": "result = tt.generate.rand_points(extent, num_points, decimals=2)"
    },
    "generate.rand_strings": {
        "name": "rand_strings",
        "category": "generate",
        "signature": "(self, min_len, max_len, length, chars='all')",
        "doc": "Return a list of the specified length ('length') of random strings between the specified minimum and maximum string length range ('min_len','max_len') using a set of random characters.\n\nParameters:\n\nmin_len (integer): the minimum length of each string in the output list.\n\nmax_len (integer): the maximum length of each string in the output list.\n\nlength (integer): the number of strings in the output list.\n\nchars (string, list): a set of characters to build random strings from. The string \"all\" may be specified to use all possible characters. Alternatively, a list may be specified to use only select characters, including \"Upper\" for upper-case alphabetic characters, \"Lower\" for lower-case alphabetic characters, \"Numeric\" for numeric characters, and \"Special\" for special characters such as punctuation.",
        "example": "result = tt.generate.rand_strings(min_len, max_len, length, chars='all')"
    },
    "generate.rand_strings_user_defined": {
        "name": "rand_strings_user_defined",
        "category": "generate",
        "signature": "(self, min_len, max_len, length, chars)",
        "doc": "Return a list of the specified length ('length') of random strings between the specified minimum and maximum string length range ('min_len','max_len') using a set of user-defined characters ('chars').\n\nParameters:\n\nmin_len (integer): the minimum length of each string in the output list.\n\nmax_len (integer): the maximum length of each string in the output list.\n\nlength (integer): the number of strings in the output list.\n\nchars (list): a list of characters to build random strings from.",
        "example": "result = tt.generate.rand_strings_user_defined(min_len, max_len, length, chars)"
    },
    "generate.triangular": {
        "name": "triangular",
        "category": "generate",
        "signature": "(self, min_val, max_val, mode, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a triangular distribution (approximately symmetric about the mode) within the specified range.\n\nParameters:\n\nmin_val (integer): the minimum value of the output data range.\n\nmax_val (integer): the maximum value of the output data range.\n\nmode (integer, float): the mode of the distribution.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.triangular(min_val, max_val, mode, length, decimals=2)"
    },
    "generate.uniform": {
        "name": "uniform",
        "category": "generate",
        "signature": "(self, min_val, max_val, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a uniform distribution.\n\nParameters:\n\nmin_val (integer or float): the minimum value of the output range.\n\nmax_val (integer or float): the maximum value of the output range.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.uniform(min_val, max_val, length, decimals=2)"
    },
    "generate.varied_arithmetic_seq": {
        "name": "varied_arithmetic_seq",
        "category": "generate",
        "signature": "(self, start, step, max_val, length)",
        "doc": "Return a list of values of the specified length ('length') in which the specified difference between subsequent values ('step') is allowed to vary within a specified limit ('max_val').\n\nParameters:\n\nstart (integer, float): the first value of the output data range.\n\nstep (integer, float): the difference between subsequent values. May be positive (for addition) or negative (for subtraction).\n\nmax_val (integer): the maximum value by which the step value is allowed to increase or decrease. Smaller values result in less variation.\n\nlength (integer): the number of values in the output list.",
        "example": "result = tt.generate.varied_arithmetic_seq(start, step, max_val, length)"
    },
    "generate.weibull": {
        "name": "weibull",
        "category": "generate",
        "signature": "(self, alpha, beta, length, decimals=2)",
        "doc": "Return a list of values of the specified length ('length') to fit a Weibull distribution.\n\nParameters:\n\nalpha (integer, float): the alpha value (scale) of the output distribution.\n\nbeta (integer, float): the beta value (shape) of the output distribution.\n\nlength (integer): the number of values in the output list.\n\ndecimals (integer): the number of decimal places values will be rounded to.",
        "example": "result = tt.generate.weibull(alpha, beta, length, decimals=2)"
    },
    "listops": {
        "name": "listops",
        "category": "category",
        "signature": "",
        "doc": "A set of general functions for manipulating lists and nested lists.",
        "functions": [
            "bool_op",
            "categorical_encoding",
            "convert_data_type",
            "display_toolbox_functions",
            "duplicate_all",
            "duplicate_value",
            "extract_evenly_spaced_indices",
            "extract_evenly_spaced_values",
            "find_duplicates",
            "flatten_nested_list",
            "group_by_equal_count",
            "group_by_equal_interval",
            "group_by_sublist_len",
            "group_consecutive_duplicates_ordered",
            "group_consecutive_duplicates_unordered",
            "has_duplicates",
            "is_type",
            "keep_nth",
            "len_sublists",
            "max_nested_depth",
            "nest_list",
            "pad_list",
            "remove_duplicates_ordered",
            "remove_duplicates_unordered",
            "remove_nth",
            "remove_value",
            "replace_value",
            "set_operation",
            "shorten_list",
            "shuffle_list",
            "total_vals_in_nested"
        ],
        "example": "result = tt.listops.bool_op(vals, vals2=None, op='and', numeric=True)"
    },
    "listops.bool_op": {
        "name": "bool_op",
        "category": "listops",
        "signature": "(self, vals, vals2=None, op='and', numeric=True)",
        "doc": "Apply a Boolean operation element-wise to one or two lists of Boolean values.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nvals2 (list): the list of values to compare against the list of operation. The input list will not be altered by the operation.\n\nop (string): the Boolean operation to apply. May be specified as 'and', 'or', 'xor', 'not', 'eq', or 'ne'.\nnumeric (bool): flag to indicate if the output values will be represented numerically (1 and 0) or as Boolean (True and False). Default is True.",
        "example": "result = tt.listops.bool_op(vals, vals2=None, op='and', numeric=True)"
    },
    "listops.categorical_encoding": {
        "name": "categorical_encoding",
        "category": "listops",
        "signature": "(self, vals, method)",
        "doc": "Encode a list of categorical values ('vals') with the one-hot, dummy, or label encoding method and return a new list.\n    \nParameters:\n    \nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n    \nmethod (string): the method of encoding. Possible methods include 'one-hot' or 'dummy' or 'label' encoding.",
        "example": "result = tt.listops.categorical_encoding(vals, method)"
    },
    "listops.convert_data_type": {
        "name": "convert_data_type",
        "category": "listops",
        "signature": "(self, vals, dtype='integer')",
        "doc": "Convert each value in an input list ('vals') to the specified data type ('dtype') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndtype (string): the data type to convert values to. May be specified as \"integer\" or \"float\" or \"string\" or \"Boolean\" for integer, float, string, or Boolean types, respectively.",
        "example": "result = tt.listops.convert_data_type(vals, dtype='integer')"
    },
    "listops.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "listops",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.listops.display_toolbox_functions()"
    },
    "listops.duplicate_all": {
        "name": "duplicate_all",
        "category": "listops",
        "signature": "(self, vals, duplicates)",
        "doc": "Duplicate all values in the input list ('vals') a specified number of times ('duplicates') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nduplicates (integer): the number of times each value in the input list will appear in the output list.",
        "example": "result = tt.listops.duplicate_all(vals, duplicates)"
    },
    "listops.duplicate_value": {
        "name": "duplicate_value",
        "category": "listops",
        "signature": "(self, vals, dup_value, duplicates)",
        "doc": "Duplicate all instances of a specified value ('dup_val') from the input list ('vals') a specified number of times ('duplicates') and return a new list. \n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndup_value (integer, float, string): the value to be duplicated. \n\nduplicates (integer): the number of times the specified value will appear in the output list, for each instance of the value in the input list.",
        "example": "result = tt.listops.duplicate_value(vals, dup_value, duplicates)"
    },
    "listops.extract_evenly_spaced_indices": {
        "name": "extract_evenly_spaced_indices",
        "category": "listops",
        "signature": "(self, vals, k)",
        "doc": "Extract k evenly-spaced value indices from an input list of values ('vals') and return a list of indices. The first and last index of the input list will be included\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nk (integer): the number of indices to extract from the input list, including the first and last.",
        "example": "result = tt.listops.extract_evenly_spaced_indices(vals, k)"
    },
    "listops.extract_evenly_spaced_values": {
        "name": "extract_evenly_spaced_values",
        "category": "listops",
        "signature": "(self, vals, k)",
        "doc": "Extract k evenly-spaced values from an input list of values ('vals') and return a list of values. The first and last value of the input list will be included\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nk (integer): the number of values to extract from the input list, including the first and last.",
        "example": "result = tt.listops.extract_evenly_spaced_values(vals, k)"
    },
    "listops.find_duplicates": {
        "name": "find_duplicates",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Find the duplicate values of an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.find_duplicates(vals)"
    },
    "listops.flatten_nested_list": {
        "name": "flatten_nested_list",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Convert an input nested list ('vals') into a one-dimensional list and return a new list.\n\nParameters:\n\nvals (list): the list of lists the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.flatten_nested_list(vals)"
    },
    "listops.group_by_equal_count": {
        "name": "group_by_equal_count",
        "category": "listops",
        "signature": "(self, vals, sub_lists)",
        "doc": "Convert an input one-dimensional list ('vals') into a nested list with a specified number of sub-lists ('sub_lists') and return a new list. Equivalent to an equal count/quantile grouping (i.e. each sub-list will have an equal number of values).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsub_lists (integer): the number of sub-lists to create from the input list. If values of the input list do not divide evenly between the number of sub-lists specified, the final sub-list in the nested list will contain fewer values than the others.",
        "example": "result = tt.listops.group_by_equal_count(vals, sub_lists)"
    },
    "listops.group_by_equal_interval": {
        "name": "group_by_equal_interval",
        "category": "listops",
        "signature": "(self, vals, intervals)",
        "doc": "Convert an input one-dimensional list ('vals') into a nested list with a specified number of sub-lists ('intervals') and return a new list. Equivalent to an equal interval grouping (i.e. sub-lists will have an equal range of values, but may be of different lengths).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nintervals (integer): the number of approximately equal-range intervals to create from the input list.",
        "example": "result = tt.listops.group_by_equal_interval(vals, intervals)"
    },
    "listops.group_by_sublist_len": {
        "name": "group_by_sublist_len",
        "category": "listops",
        "signature": "(self, vals, nested)",
        "doc": "Group values in an input one-dimensional list ('vals') into a nested list whose sublists match the lengths of sublists in an input nested list ('nested') and return a new nested list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nnested (list): the nested list to match the output sublist length to. Total number of values in all sublists must be equal to the length of the input list, which can be checked with the total_vals_in_nested function.",
        "example": "result = tt.listops.group_by_sublist_len(vals, nested)"
    },
    "listops.group_consecutive_duplicates_ordered": {
        "name": "group_consecutive_duplicates_ordered",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Group consecutive duplicates in an input list ('vals') and return a new nested list. The order the duplicates appear in the input list is preserved.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.group_consecutive_duplicates_ordered(vals)"
    },
    "listops.group_consecutive_duplicates_unordered": {
        "name": "group_consecutive_duplicates_unordered",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Group consecutive duplicates in an input list ('vals') and return a new nested list. The order the duplicates appear in the input list is not preserved.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.group_consecutive_duplicates_unordered(vals)"
    },
    "listops.has_duplicates": {
        "name": "has_duplicates",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Determine if an input list ('vals') has duplicate values and return True or False.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.has_duplicates(vals)"
    },
    "listops.is_type": {
        "name": "is_type",
        "category": "listops",
        "signature": "(self, vals, target_type='int')",
        "doc": "Check the type of each element in a list ('vals') against a target type and return a list of Boolean values.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ntarget_type (string): the type to check against. May be specified as 'int', 'float', 'string', or 'bool'. ",
        "example": "result = tt.listops.is_type(vals, target_type='int')"
    },
    "listops.keep_nth": {
        "name": "keep_nth",
        "category": "listops",
        "signature": "(self, vals, nth)",
        "doc": "Keep every nth value ('nth') from the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered\nby the operation.\n\nnth (integer): the nth value to keep. Must be greater than 1.",
        "example": "result = tt.listops.keep_nth(vals, nth)"
    },
    "listops.len_sublists": {
        "name": "len_sublists",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Calculate the length of each sub-list in the input nested list ('vals') and return a new list of lengths.\n\nParameters:\n\nvals (list):the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.len_sublists(vals)"
    },
    "listops.max_nested_depth": {
        "name": "max_nested_depth",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Calculate the maximum depth of nesting in an input list ('vals') and return the depth as an integer.\n\nParameters:\n\nvals (list): the list to be analyzed. The input list will not be altered by the operation.",
        "example": "result = tt.listops.max_nested_depth(vals)"
    },
    "listops.nest_list": {
        "name": "nest_list",
        "category": "listops",
        "signature": "(self, vals, sub_len)",
        "doc": "Convert an input one-dimensional list ('vals') into a nested list of sub-lists, each of a specified length ('sub_len'), and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsub_len (integer): the length of each sub-list. Must be greater than 0. The final sub-list may contain fewer values if the length of 'vals' is not evenly divisible by 'sub_len'.",
        "example": "result = tt.listops.nest_list(vals, sub_len)"
    },
    "listops.pad_list": {
        "name": "pad_list",
        "category": "listops",
        "signature": "(self, vals, new_len, pad_val='')",
        "doc": "Add a specified value ('pad_val') to the end of the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nnew_len (integer): the new length of the output list. Must be longer than the input list.\n\npad_val (integer, float, string): the value to add to the end of the input list until the length of the input list is equal to the second list.",
        "example": "result = tt.listops.pad_list(vals, new_len, pad_val='')"
    },
    "listops.remove_duplicates_ordered": {
        "name": "remove_duplicates_ordered",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Remove duplicate values from the input list ('vals') and return a new list. Order of list elements is preserved.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.remove_duplicates_ordered(vals)"
    },
    "listops.remove_duplicates_unordered": {
        "name": "remove_duplicates_unordered",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Remove duplicate values from the input list ('vals') and return a new list. Order of list elements is not preserved.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.remove_duplicates_unordered(vals)"
    },
    "listops.remove_nth": {
        "name": "remove_nth",
        "category": "listops",
        "signature": "(self, vals, nth)",
        "doc": "Remove every nth value ('nth') from the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nnth (integer): the nth value to remove. Must be greater than 1.",
        "example": "result = tt.listops.remove_nth(vals, nth)"
    },
    "listops.remove_value": {
        "name": "remove_value",
        "category": "listops",
        "signature": "(self, vals, to_remove)",
        "doc": "Remove all instances of a specified value ('to_remove') from the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nto_remove (integer, float, string): the value to be removed.",
        "example": "result = tt.listops.remove_value(vals, to_remove)"
    },
    "listops.replace_value": {
        "name": "replace_value",
        "category": "listops",
        "signature": "(self, vals, old_val, new_val)",
        "doc": "Replace all instances of a specified value ('old_val') with a new value ('new_val') from the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nold_val (integer, float, string): the old value to be replaced.\n\nnew_val (integer, float, string): the new value that will replace the old value.",
        "example": "result = tt.listops.replace_value(vals, old_val, new_val)"
    },
    "listops.set_operation": {
        "name": "set_operation",
        "category": "listops",
        "signature": "(self, vals1, vals2, method='union')",
        "doc": "Perform a set operation on two input lists ('vals1' and 'vals2') and return a new list.\n\nParameters:\n\nvals1 (list): the first list of values the operation will be performed on. The input list will not be altered by the operation.\n\nvals2 (list): the second list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmethod (string): the set operation to perform. Possible values are \"union\", \"intersection\", \"difference\", and \"sym_diff\".",
        "example": "result = tt.listops.set_operation(vals1, vals2, method='union')"
    },
    "listops.shorten_list": {
        "name": "shorten_list",
        "category": "listops",
        "signature": "(self, vals, new_length, position='end')",
        "doc": "Reduce the length of the input list ('vals') to a specified length ('new_length') starting from the specified position ('position') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nnew_length (integer): the new length of the output list. Values in the input list beyond the specified length will be exluded from the new list.\n\nposition (string): flag to indicate if values should be removed from the start or the end of the input list. Possible values are 'start' and 'end'",
        "example": "result = tt.listops.shorten_list(vals, new_length, position='end')"
    },
    "listops.shuffle_list": {
        "name": "shuffle_list",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Randomize the order of the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.listops.shuffle_list(vals)"
    },
    "listops.total_vals_in_nested": {
        "name": "total_vals_in_nested",
        "category": "listops",
        "signature": "(self, vals)",
        "doc": "Calculate and return the total number of values in all sublists of an input nested list ('vals').",
        "example": "result = tt.listops.total_vals_in_nested(vals)"
    },
    "math": {
        "name": "math",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing mathematical operations on lists (or nested lists) of numerical values.",
        "functions": [
            "absolute",
            "accumulate",
            "average",
            "basic_math",
            "ceiling",
            "condition_op",
            "diff_squares",
            "display_toolbox_functions",
            "floor",
            "interpolate_backward",
            "interpolate_forward",
            "interpolate_from_list",
            "interpolate_inverse_distance_weighted",
            "interpolate_linear",
            "interpolate_mean_distance",
            "interpolate_regression",
            "interpolate_rolling_average",
            "interpolate_single_value",
            "interpolate_stat",
            "is_even_odd",
            "linear_rescale",
            "linear_rescale_categorical",
            "ln",
            "log10",
            "log2",
            "max_above_threshold",
            "max_below_threshold",
            "min_above_threshold",
            "min_below_threshold",
            "min_max_clip",
            "modify_consecutive_duplicates",
            "negate",
            "next_even",
            "next_odd",
            "normalize",
            "percent_clip",
            "power",
            "reciprocal",
            "remove_non_numeric",
            "remove_threshold_condition",
            "root",
            "rounding",
            "sum_squares",
            "to_degrees",
            "to_radians",
            "trig_ops",
            "trunc"
        ],
        "example": "result = tt.math.absolute(vals, decimals=2)"
    },
    "math.absolute": {
        "name": "absolute",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the absolute value of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.absolute(vals, decimals=2)"
    },
    "math.accumulate": {
        "name": "accumulate",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "For every value in an input list ('vals'), calculate the cumulative sum and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.accumulate(vals, decimals=2)"
    },
    "math.average": {
        "name": "average",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the mean of the input list ('vals') and return a single value.\n\nParameters:\n\nvals (list): the list of values (or nested list) the operation will be performed on. The input list or lists will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.average(vals, decimals=2)"
    },
    "math.basic_math": {
        "name": "basic_math",
        "category": "math",
        "signature": "(self, vals, operand, mode='add', decimals=2)",
        "doc": "Perform a basic arithmetic operation on a list of values ('vals'), either with a constant number or pairwise element-wise with another list of equal length and return a new list.\n\nParameters:\n\nvals (list): the list of numeric values the operation will be performed on. The input list or lists will not be altered by the operation.\n\noperand (integer, float, list): either a constant number to apply to each element in 'vals', or a list of equal length for pairwise element-wise operations.\n\nmode (string): the arithmetic operation to perform. Must be one of 'add', 'subtract', 'multiply', 'divide'.\n\ndecimals (integer): the number of decimal places float values will be rounded to. ",
        "example": "result = tt.math.basic_math(vals, operand, mode='add', decimals=2)"
    },
    "math.ceiling": {
        "name": "ceiling",
        "category": "math",
        "signature": "(self, vals)",
        "doc": "Calculate the ceiling (the smallest integer greater than or equal to) of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.math.ceiling(vals)"
    },
    "math.condition_op": {
        "name": "condition_op",
        "category": "math",
        "signature": "(self, vals, list_or_val, op='lt', numeric=True)",
        "doc": "Evaluate a conditional operation element-wise on a list of numeric values and return a new list of Boolean values.\n\nParameters:\n\nvals (list): the list of numeric  values the operation will be performed on. The input list will not be altered by the operation.\n\nlist_or_val (int, float, list): either a single threshold value or a list of values of the same length as 'vals'.\n\nop (string): the conditional operation to apply. May be specified as 'lt' (<), 'gt' (>), 'le' (<=), 'ge' (>=), 'eq' (==), or 'ne' (!=).\n\nnumeric (bool): flag to indicate if the output values will be represented numerically (1 and 0) or as Boolean (True and False). Default is True.",
        "example": "result = tt.math.condition_op(vals, list_or_val, op='lt', numeric=True)"
    },
    "math.diff_squares": {
        "name": "diff_squares",
        "category": "math",
        "signature": "(self, x_var, y_var, decimals=2)",
        "doc": "Calculate and return the difference of squared deviations between two input variables.\n\nParameters:\n\nx_var (list): the list of values representing the x variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the y variable the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.diff_squares(x_var, y_var, decimals=2)"
    },
    "math.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "math",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.math.display_toolbox_functions()"
    },
    "math.floor": {
        "name": "floor",
        "category": "math",
        "signature": "(self, vals)",
        "doc": "Calculate the floor (the largest integer less than or equal to) of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.math.floor(vals)"
    },
    "math.interpolate_backward": {
        "name": "interpolate_backward",
        "category": "math",
        "signature": "(self, vals, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using the valid value immediately following each missing or invalid value and return a new list. This method will not be able to fill missing or invalid values in the last position.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nto_fill (int, float, str, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = tt.math.interpolate_backward(vals, to_fill='')"
    },
    "math.interpolate_forward": {
        "name": "interpolate_forward",
        "category": "math",
        "signature": "(self, vals, to_fill='')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using the valid value immediately preceding each missing or invalid value and return a new list. This method will not be able to fill missing or invalid values in the first position.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nto_fill (int, float, str, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = tt.math.interpolate_forward(vals, to_fill='')"
    },
    "math.interpolate_from_list": {
        "name": "interpolate_from_list",
        "category": "math",
        "signature": "(self, vals, fill_list, to_fill='')",
        "doc": "Replace each missing or invalid value ('to_fill') in a list ('vals') with the corresponding value from another list ('fill_list') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfill_list (list): the list of values that will be used to fill missing values. Must be the same length as 'vals'.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value. ",
        "example": "result = tt.math.interpolate_from_list(vals, fill_list, to_fill='')"
    },
    "math.interpolate_inverse_distance_weighted": {
        "name": "interpolate_inverse_distance_weighted",
        "category": "math",
        "signature": "(self, vals, distance, power=2, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using an inverse distance weighted (IDW) technique and return a new list. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndistance (integer): the number of values before and after each missing or invalid value to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\npower (integer): the power of the inverse distance weighting function. Higher values will give greater weight to nearer values i.e. nearer values will contribute more strongly to the interpolated value.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.interpolate_inverse_distance_weighted(vals, distance, power=2, to_fill='', decimals=2)"
    },
    "math.interpolate_linear": {
        "name": "interpolate_linear",
        "category": "math",
        "signature": "(self, vals, to_fill='', direction='forward')",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using a linear interpolation technique and return a new list. This method will not be able to fill missing or invalid values at either the beginning or end of the list, depending on the direction of interpolation.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nto_fill (int, float, str, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndirection (str): the direction of interpolation applied after the linear interpolation. May be specified as \"forward\" for a forward interpolation (missing or invalid values at the beginning of the list will not be interpolated) or \"backward\" for a backward interpolation (missing or invalid values at the end of the list will not be interpolated).",
        "example": "result = tt.math.interpolate_linear(vals, to_fill='', direction='forward')"
    },
    "math.interpolate_mean_distance": {
        "name": "interpolate_mean_distance",
        "category": "math",
        "signature": "(self, vals, distance, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using the average of valid values before and after each missing or invalid value and return a new list. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndistance (integer): the number of values before and after each missing or invalid value to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.interpolate_mean_distance(vals, distance, to_fill='', decimals=2)"
    },
    "math.interpolate_regression": {
        "name": "interpolate_regression",
        "category": "math",
        "signature": "(self, vals, x_vals, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals')\nby performing a linear regression between the values of the specified list ('vals') and a second list ('x_vals') and return a new list. Missing or invalid values will be interpolated as floats.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nx_vals (list): the list of values to perform a linear regression with for interpolation. Only valid (numeric) values within this list will be used for interpolation. Must be the same length as 'vals'.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.interpolate_regression(vals, x_vals, to_fill='', decimals=2)"
    },
    "math.interpolate_rolling_average": {
        "name": "interpolate_rolling_average",
        "category": "math",
        "signature": "(self, vals, window, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using the average of valid values within a rolling window of previous values and return a new list. Missing or invalid values will be interpolated as floats. This technique is best suited to ordered data where the order is meaningful (e.g. data ordered by date or time).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nwindow (integer): the number of previous values to use for interpolation. Only valid (numeric) values within this range will be used for interpolation.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.interpolate_rolling_average(vals, window, to_fill='', decimals=2)"
    },
    "math.interpolate_single_value": {
        "name": "interpolate_single_value",
        "category": "math",
        "signature": "(self, vals, fill_val, to_fill='')",
        "doc": "Replace each missing or invalid value ('to_fill') in a list ('vals') with a single specified value ('fill_val') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nfill_val (integer, float, string): the new value that will replace missing or invalid values.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = tt.math.interpolate_single_value(vals, fill_val, to_fill='')"
    },
    "math.interpolate_stat": {
        "name": "interpolate_stat",
        "category": "math",
        "signature": "(self, vals, stat, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') in the specified list ('vals') using the specified statistic ('stat') of all valid values within that list and return a new list. Missing or invalid values will be interpolated as floats.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nstat (string): the specific statistic to return. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\".\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to. ",
        "example": "result = tt.math.interpolate_stat(vals, stat, to_fill='', decimals=2)"
    },
    "math.is_even_odd": {
        "name": "is_even_odd",
        "category": "math",
        "signature": "(self, vals, mode='even', numeric=True)",
        "doc": "Evaluate if each numeric value in the input list ('vals') is even or odd and return a list of Boolean values.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmode (string): specify 'even' or 'odd' to determine which check to perform.\n\nnumeric (bool): flag to indicate if the output values will be represented numerically (1 and 0) or as Boolean (True and False). Default is True.",
        "example": "result = tt.math.is_even_odd(vals, mode='even', numeric=True)"
    },
    "math.linear_rescale": {
        "name": "linear_rescale",
        "category": "math",
        "signature": "(self, vals, new_min, new_max, inverted=False, decimals=2)",
        "doc": "Rescale each value in an input list ('vals') to fit within a specified range ('new_min','new_max') and return a new list. The rescale function performs a linear stretch.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nnew_min (integer, float): the new minimum value of the data after rescaling.\n\nnew_max (integer, float): the new maximum value of the data after rescaling.\n\ninverted (Boolean): flag to indicate if the rescaled values will be inverted so that lower values in the input data are rescaled to higher values in the output data and vice versa.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.linear_rescale(vals, new_min, new_max, inverted=False, decimals=2)"
    },
    "math.linear_rescale_categorical": {
        "name": "linear_rescale_categorical",
        "category": "math",
        "signature": "(self, vals, variables, new_min, new_max, decimals=2, inverted=False)",
        "doc": "Rescale each categorical value (integer or string) in an input list ('vals') to fit within a specified numerical range ('new_min','new_max') and return a new list. The rescale function performs a linear stretch.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nvariables (list): the categorical variables to rescale, in the order they will be rescaled (i.e. the first variable will be assigned the new minimum, and the last variable will be assigned the new maximum). Must contain any/all possible values in the input list.\n\nnew_min (integer, float): the new minimum value of the data after rescaling.\n\nnew_max (integer, float): the new maximum value of the data after rescaling.\n\ninverted (Boolean): flag to indicate if the rescaled values will be inverted so that lower values in the input data are rescaled to higher values in the output data and vice versa.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.linear_rescale_categorical(vals, variables, new_min, new_max, decimals=2, inverted=False)"
    },
    "math.ln": {
        "name": "ln",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the natural logarithm of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.ln(vals, decimals=2)"
    },
    "math.log10": {
        "name": "log10",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the base-10 logarithm of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.log10(vals, decimals=2)"
    },
    "math.log2": {
        "name": "log2",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the base-2 logarithm of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.log2(vals, decimals=2)"
    },
    "math.max_above_threshold": {
        "name": "max_above_threshold",
        "category": "math",
        "signature": "(self, vals, thresh)",
        "doc": "Calculate and return the maximum value of an input list ('vals') greater than a specified threshold ('thresh').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nthresh (integer, float): the threshold for determining the maximum value of the input list. Only values greater than the threshold will be used to calculate the maximum.",
        "example": "result = tt.math.max_above_threshold(vals, thresh)"
    },
    "math.max_below_threshold": {
        "name": "max_below_threshold",
        "category": "math",
        "signature": "(self, vals, thresh)",
        "doc": "Calculate and return the maximum value of an input list ('vals') less than a specified threshold ('thresh').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nthresh (integer, float): the threshold for determining the maximum value of the input list. Only values less than the threshold will be used to calculate the maximum.",
        "example": "result = tt.math.max_below_threshold(vals, thresh)"
    },
    "math.min_above_threshold": {
        "name": "min_above_threshold",
        "category": "math",
        "signature": "(self, vals, thresh)",
        "doc": "Calculate and return the minimum value of an input list ('vals') greater than a specified threshold ('thresh').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nthresh (integer, float): the threshold for determining the minimum value of the input list. Only values greater than the threshold will be used to calculate the minimum.",
        "example": "result = tt.math.min_above_threshold(vals, thresh)"
    },
    "math.min_below_threshold": {
        "name": "min_below_threshold",
        "category": "math",
        "signature": "(self, vals, thresh)",
        "doc": "Calculate and return the minimum value of an input list ('vals') less than a specified threshold ('thresh').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nthresh (integer, float): the threshold for determining the minimum value of the input list. Only values less than the threshold will be used to calculate the minimum.",
        "example": "result = tt.math.min_below_threshold(vals, thresh)"
    },
    "math.min_max_clip": {
        "name": "min_max_clip",
        "category": "math",
        "signature": "(self, vals, min_val=None, max_val=None, decimals=2)",
        "doc": "Clip each value in an input list ('vals') to fit within the specified minimum ('min_val') and/or maximum ('max_val') value range and return a new list. Values greater than the maximum or less than the minimum will be set to the specified maximum or specified minimum, respectively. \n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmin_val (integer, float): the minimum value from the input list that will be included in the output list. Input values smaller than the minimum will be set to the minimum. May be left unspecified for a one-tail clip.\n\nmax_val (integer, float): the maximum value from the input list that will be included in the output list. Input values larger than the maximum will be set to the maximum. May be left unspecified for a one-tail clip.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.min_max_clip(vals, min_val=None, max_val=None, decimals=2)"
    },
    "math.modify_consecutive_duplicates": {
        "name": "modify_consecutive_duplicates",
        "category": "math",
        "signature": "(self, vals, mod_val, method='add')",
        "doc": "Modify consecutive duplicate values in an input list ('vals') by a specified value ('mod_val') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmod_val (integer, float): the value to modify consecutive duplicates by.\n\nmethod (string): the method of modifying consecutive values. May be specified as 'add' to add the modifying value to consecutive duplicates, or 'subtract' to subtract the modifying value from consecutive duplicates.",
        "example": "result = tt.math.modify_consecutive_duplicates(vals, mod_val, method='add')"
    },
    "math.negate": {
        "name": "negate",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Negate each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.negate(vals, decimals=2)"
    },
    "math.next_even": {
        "name": "next_even",
        "category": "math",
        "signature": "(self, vals, direction='Up')",
        "doc": "Convert each odd value in an input list ('vals') to the next even number and return a new list. Even numbers in the given list will not be modified in the output list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. Input values should only be integer values. The input list will not be altered by the operation.\n\ndirection (string): the direction of conversion. A value of \"Up\" indicates that odd numbers will be rounded up to the nearest even number, while a value of \"Down\" indicates that odd numbers will be rounded down to the nearest even number.",
        "example": "result = tt.math.next_even(vals, direction='Up')"
    },
    "math.next_odd": {
        "name": "next_odd",
        "category": "math",
        "signature": "(self, vals, direction='Up')",
        "doc": "Convert each even value in an input list ('vals') to the next odd number and return a new list. Odd numbers in the input list will not be modified in the output list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. Input values should only be integer values. The input list will not be altered by the operation.\n\ndirection (string): the direction of conversion. A value of \"Up\" indicates that even numbers will be rounded up to the nearest odd number, while a value of \"Down\" indicates that even numbers will be rounded down to the nearest odd number.",
        "example": "result = tt.math.next_odd(vals, direction='Up')"
    },
    "math.normalize": {
        "name": "normalize",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Normalize the values in the specified list ('vals') to a range between 0 and 1 using min-max scaling and return a new list. Missing or invalid values will be ignored. Normalized values will be returned as floats.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.normalize(vals, decimals=2)"
    },
    "math.percent_clip": {
        "name": "percent_clip",
        "category": "math",
        "signature": "(self, vals, percent, tail='Both', decimals=2)",
        "doc": "Clip each value in an input list ('vals') to fit within the specified percentage ('percent') of either/both tails of the distribution. Values greater than or less than the percentage clip will be set to the maximum or minimum value, respectively.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\npercent (integer): the percentage of values to clip from either/both tails of the distribution.\n\ntail (string): which tail of the distribution to apply the clip to. A value of \"Upper\" or \"Lower\" may be specified for an upper or lower one-tail clip respectively. A value of \"Both\" will clip values at both ends of the distribution.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.percent_clip(vals, percent, tail='Both', decimals=2)"
    },
    "math.power": {
        "name": "power",
        "category": "math",
        "signature": "(self, vals, power, decimals=2)",
        "doc": "Raise each value in an input list ('vals') to a specified power ('power') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\npower (integer, float): the exponent to raise each element in the list by.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.power(vals, power, decimals=2)"
    },
    "math.reciprocal": {
        "name": "reciprocal",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the reciprocal (1/value) of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.reciprocal(vals, decimals=2)"
    },
    "math.remove_non_numeric": {
        "name": "remove_non_numeric",
        "category": "math",
        "signature": "(self, vals)",
        "doc": "Remove non-numeric values from an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.math.remove_non_numeric(vals)"
    },
    "math.remove_threshold_condition": {
        "name": "remove_threshold_condition",
        "category": "math",
        "signature": "(self, vals, thresh, condition)",
        "doc": "Remove values from an input list ('vals') based on an equality threshold condition and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nthresh (integer, float): the threshold to evaluate each value in the list against.\n\ncondition (string): the condition placed upon each value in the list to determine if that value will be removed. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.",
        "example": "result = tt.math.remove_threshold_condition(vals, thresh, condition)"
    },
    "math.root": {
        "name": "root",
        "category": "math",
        "signature": "(self, vals, root, decimals=2)",
        "doc": "Calculate the nth root ('root') of each value in an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nroot (integer): the nth root to take of each value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.root(vals, root, decimals=2)"
    },
    "math.rounding": {
        "name": "rounding",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Round each value in an input list ('vals') to a specified number of decimal places ('decimals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.rounding(vals, decimals=2)"
    },
    "math.sum_squares": {
        "name": "sum_squares",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate and return the sum of squared deviations from the mean for an input variable.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.sum_squares(vals, decimals=2)"
    },
    "math.to_degrees": {
        "name": "to_degrees",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Convert each value in an input list ('vals') from radians to degrees and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.to_degrees(vals, decimals=2)"
    },
    "math.to_radians": {
        "name": "to_radians",
        "category": "math",
        "signature": "(self, vals, decimals=2)",
        "doc": "Convert each value in an input list ('vals') from degrees to radians and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.to_radians(vals, decimals=2)"
    },
    "math.trig_ops": {
        "name": "trig_ops",
        "category": "math",
        "signature": "(self, vals, operation, decimals=2)",
        "doc": "Apply a trigonometric operation to each value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\noperation (string): the trigonometric operation to apply. Possible values include \"sin\", \"cos\", \"tan\", \"asin\", \"acos\", \"atan\", \"sinh\", \"cosh\", \"tanh\", \"asinh\", \"acosh\", \"atanh\".\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.math.trig_ops(vals, operation, decimals=2)"
    },
    "math.trunc": {
        "name": "trunc",
        "category": "math",
        "signature": "(self, vals)",
        "doc": "Truncate each value in an input list ('vals') toward zero and return a new list.\n\nParameters:\n\nvals (list): the list of numeric values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.math.trunc(vals)"
    },
    "matrix": {
        "name": "matrix",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing matrix operations and algebra on matrices.",
        "functions": [
            "determinant",
            "display_toolbox_functions",
            "identity",
            "inner_product",
            "inverse",
            "matrix_addition",
            "matrix_multiplication",
            "matrix_subtraction",
            "matrix_to_table",
            "new_matrix",
            "random_matrix",
            "row_addition",
            "row_multiplication",
            "scalar_multiplication",
            "switch_rows",
            "table_to_matrix",
            "trace",
            "transpose",
            "zero_matrix"
        ],
        "example": "result = tt.matrix.determinant(matrix)"
    },
    "matrix.determinant": {
        "name": "determinant",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Return the determinant of the input Matrix object ('matrix'). This function is currently only applicable to 2x2 matrices and 3x3 matrices, and None will be returned if a matrix with other dimensions is passed.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.determinant(matrix)"
    },
    "matrix.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "matrix",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.matrix.display_toolbox_functions()"
    },
    "matrix.identity": {
        "name": "identity",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Return the identity matrix of the input Matrix object ('matrix'). The identity matrix is a a matrix that, when multiplied by some matrix A, returns A.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.identity(matrix)"
    },
    "matrix.inner_product": {
        "name": "inner_product",
        "category": "matrix",
        "signature": "(self, vector_A, vector_B)",
        "doc": "Calculate the inner product of two vectors (1D matrices) and return a scalar value. If the vectors are not of equal length or vectors are not 1D, None will be returned.\n\nParameters:\n\nvector_A (object): the first 1D matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nvector_B (object): the second 1D matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.inner_product(vector_A, vector_B)"
    },
    "matrix.inverse": {
        "name": "inverse",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Return the inverse matrix of the input Matrix object ('matrix'). This function is currently only applicable to 2x2 matrices and 3x3 matrices, and None will be returned if a matrix with other dimensions is passed. If the determinant of the matrix is 0, the inverse is undefined and None will be returned.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.inverse(matrix)"
    },
    "matrix.matrix_addition": {
        "name": "matrix_addition",
        "category": "matrix",
        "signature": "(self, matrix_A, matrix_B)",
        "doc": "Add the elements of two matrices element-wise and return a new Matrix object. If two matrices do not have equivalent dimensions, the addition is undefined and None will be returned.\n\nParameters:\n\nmatrix_A (object): the first Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nmatrix_B (object): the second Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.matrix_addition(matrix_A, matrix_B)"
    },
    "matrix.matrix_multiplication": {
        "name": "matrix_multiplication",
        "category": "matrix",
        "signature": "(self, matrix_A, matrix_B)",
        "doc": "Multiply two matrices ('matrix_A' and 'matrix_B') and return a new Matrix object. Matrix multiplication is only defined when the number of columns in 'matrix_A' equals the number of rows in 'matrix_B'. If the dimensions are incompatible, None will be returned.\n\nParameters:\n\nmatrix_A (object): the first Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nmatrix_B (object): the second Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.matrix_multiplication(matrix_A, matrix_B)"
    },
    "matrix.matrix_subtraction": {
        "name": "matrix_subtraction",
        "category": "matrix",
        "signature": "(self, matrix_A, matrix_B)",
        "doc": "Subtract the elements of two matrices element-wise and return a new Matrix object. If two matrices do not have equivalent dimensions, the subtraction is undefined and None will be returned.\n\nParameters:\n\nmatrix_A (object): the first Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nmatrix_B (object): the second Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.matrix_subtraction(matrix_A, matrix_B)"
    },
    "matrix.matrix_to_table": {
        "name": "matrix_to_table",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Convert a Matrix object ('matrix') into a Table object.\n\nParameters:\n\nmatrix (object): the Matrix object to be converted into a Table object.",
        "example": "result = tt.matrix.matrix_to_table(matrix)"
    },
    "matrix.new_matrix": {
        "name": "new_matrix",
        "category": "matrix",
        "signature": "(self, rows)",
        "doc": "Create a matrix from a nested list representing the rows of the matrix and return a Matrix object.\n\nParameters:\n\nrows (list): a nested list representing the rows of the matrix.",
        "example": "result = tt.matrix.new_matrix(rows)"
    },
    "matrix.random_matrix": {
        "name": "random_matrix",
        "category": "matrix",
        "signature": "(self, rows, columns, min, max)",
        "doc": "Create a random Matrix object of the specified dimensions with values within the specified minimum ('min') and maximum ('max').\n\nParameters:\n\nrows (integer): the number of rows in the output Matrix object.\n\ncolumns (integer): the number of columns in the output Matrix object.\n\nmin (integer): the minimum value in the output Matrix object.\n\nmax (integer): the maximum value in the output Matrix object.",
        "example": "result = tt.matrix.random_matrix(rows, columns, min, max)"
    },
    "matrix.row_addition": {
        "name": "row_addition",
        "category": "matrix",
        "signature": "(self, matrix, row_1, row_2)",
        "doc": "Add the elements of two rows in a Matrix object ('matrix') and replace the first row. A new Matrix object is returned. Row addition is an elementary matrix row operation.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nrow_1 (integer): the index of the first row to be added. This row will be replaced.\n\nrow_2 (integer): the index of the second row to be added.",
        "example": "result = tt.matrix.row_addition(matrix, row_1, row_2)"
    },
    "matrix.row_multiplication": {
        "name": "row_multiplication",
        "category": "matrix",
        "signature": "(self, matrix, row, constant)",
        "doc": "Multiply a specified row ('row') by a non-zero constant ('constant') and return a new Matrix object. Row multiplication is an elementary matrix row operation.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nrow (integer): the index of the row to be multiplied.\n\nconstant (integer, float): the non-zero constant to multiply the row values by.",
        "example": "result = tt.matrix.row_multiplication(matrix, row, constant)"
    },
    "matrix.scalar_multiplication": {
        "name": "scalar_multiplication",
        "category": "matrix",
        "signature": "(self, matrix, scalar)",
        "doc": "Multiply each element of the input Matrix object by a scalar value and return a new Matrix object.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nscalar (integer, float): the scalar to multiply each element of the Matrix object by.",
        "example": "result = tt.matrix.scalar_multiplication(matrix, scalar)"
    },
    "matrix.switch_rows": {
        "name": "switch_rows",
        "category": "matrix",
        "signature": "(self, matrix, row_1, row_2)",
        "doc": "Switch the position of any two rows in the input Matrix object ('matrix') and return a new Matrix object. Row switching is an elementary matrix row operation.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.\n\nrow_1 (integer): the index of the first row to be switched.\n\nrow_2 (integer): the index of the second row to be switched.",
        "example": "result = tt.matrix.switch_rows(matrix, row_1, row_2)"
    },
    "matrix.table_to_matrix": {
        "name": "table_to_matrix",
        "category": "matrix",
        "signature": "(self, table)",
        "doc": "Convert a Table object ('table') into a matrix and return a new Matrix object.\n\nParameters:\n\ntable (object): the Table object to be converted into a Matrix object.",
        "example": "result = tt.matrix.table_to_matrix(table)"
    },
    "matrix.trace": {
        "name": "trace",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Calculate and return the summation of the diagonal elements of a square Matrix object ('matrix'). If the matrix object is not square (i.e., if the number of rows and columns are not equal), None will be returned.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.trace(matrix)"
    },
    "matrix.transpose": {
        "name": "transpose",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Transpose the Matrix object ('matrix') and return a new Matrix object.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.transpose(matrix)"
    },
    "matrix.zero_matrix": {
        "name": "zero_matrix",
        "category": "matrix",
        "signature": "(self, matrix)",
        "doc": "Create a zero matrix to match the dimensions of an input Matrix object and return a new Matrix object.\n\nParameters:\n\nmatrix (object): the Matrix object the operation will be performed on. The input Matrix will not be modified by the operation.",
        "example": "result = tt.matrix.zero_matrix(matrix)"
    },
    "plot": {
        "name": "plot",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for visualizing lists of data with common plot types.",
        "functions": [
            "bar_chart",
            "box_plot",
            "coordinate_plot",
            "display_toolbox_functions",
            "grouped_bar_chart",
            "grouped_box_plot",
            "histogram",
            "line_plot",
            "pie_chart",
            "scatter_plot"
        ],
        "example": "tt.plot.bar_chart(variable, title='Bar Chart', x_label='Category', y_label='Count', num_ticks=6, colour='#4e79a7', margin=60, filename='bar_chart.html', open_browser=False)"
    },
    "plot.bar_chart": {
        "name": "bar_chart",
        "category": "plot",
        "signature": "(self, variable, title='Bar Chart', x_label='Category', y_label='Count', num_ticks=6, colour='#4e79a7', margin=60, filename='bar_chart.html', open_browser=False)",
        "doc": "Create a bar chart from a list of categorical values ('variable') and configure chart elements.\n\nParameters:\n\nvariable (list): the list of categorical values. \n\ntitle (string): the title of the bar chart.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_ticks (integer): The number of tick marks to draw on the y axis.\n\ncolour (string): the colour of the bars. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "tt.plot.bar_chart(variable, title='Bar Chart', x_label='Category', y_label='Count', num_ticks=6, colour='#4e79a7', margin=60, filename='bar_chart.html', open_browser=False)"
    },
    "plot.box_plot": {
        "name": "box_plot",
        "category": "plot",
        "signature": "(self, data, labels=None, title='Box Plot', x_label='Categories', y_label='Values', num_ticks=5, colour='#4e79a7', margin=60, filename='box_plot.html', open_browser=False)",
        "doc": "Create a box plot from a list of data series ('data') and configure plot elements. One box will be created per series.\n\nParameters:\n\ndata (list): the nested list where each sub-list contains numeric values for one category.\n\nlabels (list): the list of category labels for the x axis. Must be the same length as data.\n\ntitle (string): the title of the box plot.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_ticks (integer): the number of tick marks to draw on the y axis.\n\ncolour (string): the colour of the boxes. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.box_plot(data, labels=None, title='Box Plot', x_label='Categories', y_label='Values', num_ticks=5, colour='#4e79a7', margin=60, filename='box_plot.html', open_browser=False)"
    },
    "plot.coordinate_plot": {
        "name": "coordinate_plot",
        "category": "plot",
        "signature": "(self, points, overlays=None, standard_dists=None, title='Coordinate Plot', x_label='X Coordinate', y_label='Y Coordinate', num_ticks=5, point_size=3, point_colours=None, overlay_colours=None, standard_dists_colours=None, legend=False, point_labels=None, overlay_labels=None, standard_dists_labels=None, tooltip_threshold=100, margin=60, filename='coordinate_plot.html', open_browser=False)",
        "doc": "Create a coordinate plot for any number of PointDatasets ('points'), additional point overlays such as centroids ('overlays') and standard distances (\"st) and configure plot elements.\n\nParameters:\n\npoints (object, list): the PointDataset or list of PointDatasets to be visualized. PointDatasets may contain any number of points. PointDatasets are the primary data layers to be visualized.\n\noverlays (object, tuple, list): the Point, list, tuple or list of point-like coordinate objects to be visualized.\n\nstandard_dists (integer, float, list): the numerical value or list of numerical values representing the standard distances to be visualized. Standard distances (weighted and unweighted) can be calculated with the .points toolbox.\n\ntitle (string): the title of the coordinate plot. \n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis. \n\nnum_ticks (integer): the number of tick marks to draw on each axis.\n\npoint_size (integer): the radius of points on the plot (in pixels).\n\npoint_colours (string, list): if a single PointDataset is given, this should be a single string representing the colour of the points. If multiple PointDatasets are given, this should be a list of strings corresponding to the colour of each PointDataset. If no colours are specified or the number of specified colours does not equal the number of PointDatasets, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\noverlay_colours (string, list): if a single point-like object is given, this should be a single string representing the colour of the points. If multiple point-like objects are given, this should be a list of strings corresponding to the colour of each point. If no colours are specified or the number of specified colours does not equal the number of points, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nstandard_dists_colours (string, list): if a single standard distance is given, this should be a single string representing the colour of the standard distance to be visualized. If multiple standard distances are given, this should be a list of strings corresponding to the colour of each standard distance. If no colours are specified or the number of specified colours does not equal the number of standard distances, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\npoint_labels (string, list): if a single PointDataset is given, this should be a single string representing the label of the PointDataset. If multiple PointDatasets are given, this should be a list of strings representing the labels of each PointDataset. If no labels are given, generic labels will be generated. A legend must be created to view point labels.\n\noverlay_labels (string, list): if a single point-like object is given, this should be a single string representing the label of the point. If multiple point-like objects are given, this should be a list of strings representing the labels of each variable. If no labels are given, generic labels will be generated. A legend must be created to view point labels.\n\nstandard_dists_labels (string, list): if a single standard distance is given, this should be a single string representing the label of the standard distance. If multiple standard distances are given, this should be a list of strings representing the labels of each standard distance. If no labels are given, generic labels will be generated. A legend must be created to view point labels.\n\ntooltip_threshold (integer): the maximum number of points per series for which explicit hover-based tooltips are included.\n\nmargin (integer): the margin size (in pixels) around the plot area. \n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.coordinate_plot(points, overlays=None, standard_dists=None, title='Coordinate Plot', x_label='X Coordinate', y_label='Y Coordinate', num_ticks=5, point_size=3, point_colours=None, overlay_colours=None, standard_dists_colours=None, legend=False, point_labels=None, overlay_labels=None, standard_dists_labels=None, tooltip_threshold=100, margin=60, filename='coordinate_plot.html', open_browser=False)"
    },
    "plot.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "plot",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.plot.display_toolbox_functions()"
    },
    "plot.grouped_bar_chart": {
        "name": "grouped_bar_chart",
        "category": "plot",
        "signature": "(self, variable, group_labels, category_labels=None, title='Grouped Bar Chart', x_label='Groups', y_label='Count', num_ticks=2, colours=None, margin=60, filename='grouped_bar_chart.html', open_browser=False)",
        "doc": "Create a grouped bar chart for categorical or numerical input data and configure plot elements.\n    \nParameters:\n    \nvariable (list): the list of values representing the data to be visualized. If values are strings, categories will be inferred automatically. If values are numerical counts, then category_labels must be supplied.\n    \ngroup_labels (list): the labels for each group. Must match the number of sub-lists in variable.\n    \ncategory_labels (list): the labels for categories within each group. Required if values are numerical counts. Ignored if values are categorical strings, in which case categories are inferred automatically.\n    \ntitle (string): the title of the bar chart.\n    \nx_label (string): the label of the x axis.\n    \ny_label (string): the label of the y axis.\n    \nnum_ticks (integer): the number of tick marks to draw on the y axis.\n    \ncolours (list): the colour of the bars, one per category. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n    \nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "tt.plot.grouped_bar_chart(variable, group_labels, category_labels=None, title='Grouped Bar Chart', x_label='Groups', y_label='Count', num_ticks=2, colours=None, margin=60, filename='grouped_bar_chart.html', open_browser=False)"
    },
    "plot.grouped_box_plot": {
        "name": "grouped_box_plot",
        "category": "plot",
        "signature": "(self, data, group_labels, category_labels, title='Grouped Box Plot', x_label='Groups', y_label='Values', num_ticks=5, colours=None, margin=60, filename='grouped_box_plot.html', open_browser=False)",
        "doc": "Create a grouped box plot for multiple categories across groups and configure plot elements.\n\nParameters:\n\ndata (list): the nested list representing groups and categories to visualize. The outermost lists are groups, the mid-level lists are categories within groups, and the innermost lists must contain numeric values.\n                    \ngroup_labels (list): labels for each group (e.g., years). Must match the number of groups in data.\n\ncategory_labels (list): labels for categories within each group. Must match the number of categories in each group.\n\ntitle (string): the title of the box plot.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_ticks (integer): the number of tick marks to draw on the y axis.\n\ncolours (list): the colour of the boxes, one per category. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.grouped_box_plot(data, group_labels, category_labels, title='Grouped Box Plot', x_label='Groups', y_label='Values', num_ticks=5, colours=None, margin=60, filename='grouped_box_plot.html', open_browser=False)"
    },
    "plot.histogram": {
        "name": "histogram",
        "category": "plot",
        "signature": "(self, variable, title='Histogram', x_label='Value', y_label='Frequency', num_bins=None, bar_colour=None, margin=60, filename='histogram.html', open_browser=False)",
        "doc": "Create a histogram for a single data series ('variable') and configure plot elements.\n\nParameters:\n\nvariable (list): the list of numerical values to be visualized. Values must be integers or floating point.\n\ntitle (string): the title of the histogram.\n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.\n\nnum_bins (integer, optional): the number of bins to divide the data into. If not specified, the optimal number of bins is calculated using Sturge's Formula.\n\nbar_colour (string, optional): the colour of the bars. If not specified, a random colour will be generated. Colours may be specified as a common colour name or hex code.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.histogram(variable, title='Histogram', x_label='Value', y_label='Frequency', num_bins=None, bar_colour=None, margin=60, filename='histogram.html', open_browser=False)"
    },
    "plot.line_plot": {
        "name": "line_plot",
        "category": "plot",
        "signature": "(self, x_var, y_vars, title='Line Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, line_weight=2, line_colours=None, trendline=False, trend_colours=None, legend=False, line_labels=None, margin=60, filename='line_plot.html', open_browser=False)",
        "doc": "Create a line plot for a single independent variable ('x_var') and one or more dependent variables ('y_vars')  and configure plot elements.\n\nParameters:\n\nx_var (list): the list of values representing the independent variable to be visualized. Values may be numerical (integer or floating point) or categorical strings such as dates.\n\ny_vars (list): the list of values representing the dependent variable to be visualized, or a nested list if there are multiple dependent variables to be visualized. Values must be numerical (integer or floating point). Each series must match the length of x_var.\n\ntitle (string): the title of the line plot.  \n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis.  \n\nnum_ticks (integer): the number of tick marks to draw on each axis.\n\nline_weight (integer): the stroke width of the lines on the plot (in pixels).\n\nline_colours (string, list): if a single dependent variable is given, this should be a single string representing the colour of the line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each variable. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\ntrendline (Boolean): flag to indicate if trend lines for each dependent variable will be calculated and displayed.\n\ntrend_colours (string, list): if a single dependent variable is given, this should be a single string representing the colour of the trend line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each trend line. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\nline_labels (string, list): the labels of each dependent variable series. If no labels are given, generic labels (\"Series 1\", \"Series 2\", ...) will be generated. A legend must be created to view series labels.\n\nmargin (integer): the margin size (in pixels) around the plot area.  \n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.line_plot(x_var, y_vars, title='Line Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, line_weight=2, line_colours=None, trendline=False, trend_colours=None, legend=False, line_labels=None, margin=60, filename='line_plot.html', open_browser=False)"
    },
    "plot.pie_chart": {
        "name": "pie_chart",
        "category": "plot",
        "signature": "(self, variable, title='Pie Chart', show_values=False, colours=None, legend=True, margin=60, filename='pie_chart.html', open_browser=False)",
        "doc": "Create a pie chart from a list of categorical values ('variable') and configure chart elements.\n\nParameters:\n\nvariable (list): a list of categorical values.\n\ntitle (string): the title of the pie chart.\n\nshow_values (Boolean): flag to indicate if counts and percentages should be shown in the legend beside each category label. If False, only category names are shown.\n\ncolours (list): list of colour strings to use for slices. If None, colours are auto-generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\nmargin (integer): the margin size (in pixels) around the plot area.\n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.pie_chart(variable, title='Pie Chart', show_values=False, colours=None, legend=True, margin=60, filename='pie_chart.html', open_browser=False)"
    },
    "plot.scatter_plot": {
        "name": "scatter_plot",
        "category": "plot",
        "signature": "(self, x_var, y_vars, title='Scatter Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, point_size=3, point_colour=None, point_style=None, trendline=False, trend_colour=None, legend=False, point_labels=None, tooltip_threshold=100, margin=60, filename='scatter_plot.html', open_browser=False)",
        "doc": "Create a scatter plot for a single independent variable ('x_var') and one or more dependent variables ('y_vars') and configure plot elements.\n\nParameters:\n\nx_var (list): the list of values representing the independent variable to be visualized. Values may be numerical (integer or floating point) or categorical strings such as dates.\n\ny_vars (list): the list of values representing the dependent variable to be visualized, or a nested list if there are multiple dependent variables to be visualized. Values must be numerical (integer or floating point). Each series must match the length of x_var.\n\ntitle (string): the title of the scatter plot. \n\nx_label (string): the label of the x axis.\n\ny_label (string): the label of the y axis. \n\nnum_ticks (integer): the number of tick marks to draw on each axis.\n\npoint_size (integer): the radius of points on the plot (in pixels).\n\npoint_colour (string, list): if a single dependent variable is given, this should be a single string representing the colour of the points. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each variable. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\npoint_style (string, list): the shape of points. May be specified as \"circle\", \"diamond\", \"square\", or \"triangle\". If a single dependent variable is given, this should be a single string representing the style of the points. If multiple dependent variables are given, this should be a list of strings corresponding to the style of each variable. If no styles are specified or the number of specified styles does not equal the number of dependent variables, random styles will be generated.\n\ntrendline (Boolean): flag to indicate if trend lines for each dependent variable will be calculated and displayed.\n\ntrend_colour (string, list): if a single dependent variable is given, this should be a single string representing the colour of the trend line. If multiple dependent variables are given, this should be a list of strings corresponding to the colour of each trend line. If no colours are specified or the number of specified colours does not equal the number of dependent variables, random colours will be generated. Colours may be specified as a common colour name or hex code.\n\nlegend (Boolean): flag to indicate if a legend will be displayed.\n\npoint_labels (string, list): if a single dependent variable is given, this should be a single string representing the label of the points. If multiple dependent variables are given, this should be a list of strings representing the labels of each variable. If no labels are given, generic labels will be generated. A legend must be created to view point labels.\n\ntooltip_threshold (integer): the maximum number of points per series for which explicit hover-based tooltips are included.\n\nmargin (integer): the margin size (in pixels) around the plot area. \n\nfilename (string): the name of the output file. Include the output file path in the string or prepend tt.get_out_dir() to the filename.\n\nopen_browser (Boolean): flag to indicate if the generated file should be automatically opened in the default web browser.",
        "example": "result = tt.plot.scatter_plot(x_var, y_vars, title='Scatter Plot', x_label='Independent Variable', y_label='Dependent Variable', num_ticks=5, point_size=3, point_colour=None, point_style=None, trendline=False, trend_colour=None, legend=False, point_labels=None, tooltip_threshold=100, margin=60, filename='scatter_plot.html', open_browser=False)"
    },
    "points": {
        "name": "points",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing operations on PointDatasets",
        "functions": [
            "add_attribute",
            "add_point",
            "affine_transformation",
            "attribute_as_list",
            "clip_points_by_extent",
            "cluster_summary",
            "convert_dd_to_dms",
            "convert_dms_to_dd",
            "dbscan_cluster",
            "display_toolbox_functions",
            "distance",
            "extent_area",
            "extent_center",
            "extent_perimeter",
            "filter_boolean_attribute",
            "filter_date_attribute",
            "filter_missing_invalid_attributes",
            "filter_numeric_attribute",
            "filter_text_attribute",
            "filter_type_attribute",
            "get_point",
            "interpolate_inverse_distance_weighted",
            "kmeans_cluster",
            "mean_center",
            "medoid",
            "nearest_neighbour",
            "new_point",
            "normalize_latitude",
            "normalize_longitude",
            "num_points_in_range",
            "point_density",
            "point_distribution",
            "point_in_extent",
            "points_to_table",
            "reflect",
            "remove_attribute",
            "remove_overlapping_points",
            "remove_point",
            "rename_attribute",
            "rotate",
            "sample_points",
            "scale",
            "shear",
            "spatial_join",
            "standard_distance",
            "swap_coordinates",
            "table_to_points",
            "translate",
            "translate_random_uniform",
            "unrotate_coordinates",
            "unrotate_x",
            "unrotate_y",
            "weighted_mean_center",
            "weighted_standard_distance"
        ],
        "example": "result = tt.points.add_attribute(points, attr_name, attr)"
    },
    "points.add_attribute": {
        "name": "add_attribute",
        "category": "points",
        "signature": "(self, points, attr_name, attr)",
        "doc": "Add a new attribute to each Point in a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattr_name (string): the name of the attribute to add.\n\nattr (list): the list of values representing the values of the point attribute to be added.",
        "example": "result = tt.points.add_attribute(points, attr_name, attr)"
    },
    "points.add_point": {
        "name": "add_point",
        "category": "points",
        "signature": "(self, points, point)",
        "doc": "Add a new Point object ('point') to a PointDataset ('points').\n\nParameters:\n\npoints (object): the PointDataset to add the point to.\n\npoint (object): the Point object to be added.",
        "example": "tt.points.add_point(points, point)"
    },
    "points.affine_transformation": {
        "name": "affine_transformation",
        "category": "points",
        "signature": "(self, points, dx=0.0, dy=0.0, x_factor=1.0, y_factor=1.0, angle=0.0, pivot_x=0.0, pivot_y=0.0, reflect_axis=None, x_shear=0.0, y_shear=0.0)",
        "doc": "Apply a general affine transformation (translate, scale, rotate, reflect, shear) to a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on.  The input dataset will not be altered by the operation.\n\ndx (float): translation offsets in the x direction. Default is 0.0.\n\ndy (float): translation offset in the y direction. Default is 0.0.\n\nx_factor (float): scaling factor for x coordinate. Default is 1.0.\n\ny_factor (float): scaling factor for y coordinate. Default is 1.0.\n\nangle (float): rotation angle in degrees (counterclockwise). Default is 0.0.\n\npivot_x (float): pivot point for rotation. Default is 0.0,.\n\npivot_y (float): pivot point for rotation. Default is 0.0.\n\nreflect_axis (string): optional reflection axis ('x', 'y', 'origin'). Default is None.\n\nx_shear (float): shear factor in x direction. Default is 0.0.\n\ny_shear (float): shear factor in x y directions. Default is 0.0.",
        "example": "result = tt.points.affine_transformation(points, dx=0.0, dy=0.0, x_factor=1.0, y_factor=1.0, angle=0.0, pivot_x=0.0, pivot_y=0.0, reflect_axis=None, x_shear=0.0, y_shear=0.0)"
    },
    "points.attribute_as_list": {
        "name": "attribute_as_list",
        "category": "points",
        "signature": "(self, points, attribute)",
        "doc": "Return the specified attribute ('attribute') from each point in a PointDataset ('points') as a list. Any attribute including the point id or x or y coordinates can be returned.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered.\n\nattribute (string): the point attribute to return as a list.",
        "example": "result = tt.points.attribute_as_list(points, attribute)"
    },
    "points.clip_points_by_extent": {
        "name": "clip_points_by_extent",
        "category": "points",
        "signature": "(self, points, extent, method)",
        "doc": "Remove points from a PointDataset ('points') based on a specified output bounding box extent ('extent') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nextent (list): a list representing the minimum x, minimum y, maximum x, and maximum y, in that order, of the extent to remove points from.\n\nmethod (string): the method of removing points from the extent. May be specified as \"inside\" to remove points that fall inside of the specified extent, or \"outside\" to remove points that fall outside of the specified extent.",
        "example": "result = tt.points.clip_points_by_extent(points, extent, method)"
    },
    "points.cluster_summary": {
        "name": "cluster_summary",
        "category": "points",
        "signature": "(self, points)",
        "doc": "Return a dictionary of cluster IDs and their counts from a clustered PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. Must contain a 'cluster' attribute.",
        "example": "result = tt.points.cluster_summary(points)"
    },
    "points.convert_dd_to_dms": {
        "name": "convert_dd_to_dms",
        "category": "points",
        "signature": "(self, points, d_sep='\u00b0', m_sep=\"'\", s_sep='\"')",
        "doc": "Convert each coordinate value in a PointDataset ('points') from decimal degrees to degrees, minutes, seconds and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nd_sep (string): the character that will separate the degree component of the coordinate from the other components. The default value is \u00b0.\n\nm_sep (string): the character that will separate the minute component of the coordinate from the other components. The default value is '.\n\ns_sep (string): the character that will separate the second component of the coordinate from the other components. The default value is \".",
        "example": "result = tt.points.convert_dd_to_dms(points, d_sep='\u00b0', m_sep=\"'\", s_sep='\"')"
    },
    "points.convert_dms_to_dd": {
        "name": "convert_dms_to_dd",
        "category": "points",
        "signature": "(self, points, d_sep='\u00b0', m_sep=\"'\", s_sep='\"')",
        "doc": "Convert each coordinate value in a PointDataset ('points') from degrees, minutes, seconds to decimal degrees and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nd_sep (string): the character that separates the degree component of the coordinate from the other components. The default value is \u00b0.\n\nm_sep (string): the character that separates the minute component of the coordinate from the other components. The default value is '.\n\ns_sep (string): the character that separates the second component of the coordinate from the other components. The default value is \".",
        "example": "result = tt.points.convert_dms_to_dd(points, d_sep='\u00b0', m_sep=\"'\", s_sep='\"')"
    },
    "points.dbscan_cluster": {
        "name": "dbscan_cluster",
        "category": "points",
        "signature": "(self, points, eps, min_pts, attributes=['x', 'y'])",
        "doc": "Cluster points in a PointDataset ('points') using the DBSCAN algorithm and return a new PointDataset with a 'cluster' attribute appended. Noise points are assigned cluster ID -1.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\neps (float): the maximum radius distance to consider points as neighbours.\n\nmin_pts (integer): the minimum number of points required within 'eps' distance for a point to be considered a core point.\n\nattributes (list): list of attribute headers to use for clustering. Must be numeric attributes. Must include at least two attributes.",
        "example": "result = tt.points.dbscan_cluster(points, eps, min_pts, attributes=['x', 'y'])"
    },
    "points.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "points",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.points.display_toolbox_functions()"
    },
    "points.distance": {
        "name": "distance",
        "category": "points",
        "signature": "(self, points1, points2, method='Euclidean', decimals=2)",
        "doc": "Compute the distance between each point in an input PointDataset ('points1') and the corresponding point in a second PointDataset ('points2'), and return a new PointDataset with an added 'dist' column.\n\nParameters:\n\npoints1 (object): the dataset to calculate distances for. The input dataset will not be altered by the operation.\n\npoints2 (object): the dataset of corresponding points to calculate distances to.\n\nmethod (string): the method with which to calculate distance. Possible choices are 'Euclidean' and 'Manhattan'.\n\ndecimals (integer): the number of decimal places float values will be rounded to. Default is 2.",
        "example": "result = tt.points.distance(points1, points2, method='Euclidean', decimals=2)"
    },
    "points.extent_area": {
        "name": "extent_area",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Calculate and return the area of the extent (bounding box) of a PointDataset ('points').\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places the area will be rounded to. Default is 2.",
        "example": "result = tt.points.extent_area(points, decimals=2)"
    },
    "points.extent_center": {
        "name": "extent_center",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Calculate and return the center (midpoint) of the extent (bounding box) of a PointDataset ('points') as a tuple.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places the coordinates will be rounded to. Default is 2.",
        "example": "result = tt.points.extent_center(points, decimals=2)"
    },
    "points.extent_perimeter": {
        "name": "extent_perimeter",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Calculate and return the perimeter of the extent (bounding box) of a PointDataset ('points').\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places the perimeter will be rounded to. Default is 2.",
        "example": "result = tt.points.extent_perimeter(points, decimals=2)"
    },
    "points.filter_boolean_attribute": {
        "name": "filter_boolean_attribute",
        "category": "points",
        "signature": "(self, points, attribute, condition, target)",
        "doc": "Remove points from a PointDataset ('points') that do not meet a Boolean condition placed upon an attribute ('attribute') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattribute (string): the point attribute to filter points by. Must be a header in the dataset for a Boolean attribute.\n\ncondition (string): the condition placed upon the attribute for removing points. Must be \"==\" for equality or \"!=\" for inequality.\n\ntarget (bool): the Boolean value to evaluate the condition against.",
        "example": "result = tt.points.filter_boolean_attribute(points, attribute, condition, target)"
    },
    "points.filter_date_attribute": {
        "name": "filter_date_attribute",
        "category": "points",
        "signature": "(self, points, attribute, condition, threshold)",
        "doc": "Filter a PointDataset ('points') by removing points that do not meet a specified threshold condition and return a new PointDataset. This filtering operation is performed with point attributes of date values, which must be in \"yyyy-mm-dd\" format.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattribute (string): the point attribute to filter points by. Must be a header in the dataset for a date attribute in \"yyyy-mm-dd\" format.\n\ncondition (string): the condition placed upon the point attribute for removing points. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.\n\nthreshold (string): the threshold to evaluate the condition against. Must be in \"yyyy-mm-dd\" format.",
        "example": "result = tt.points.filter_date_attribute(points, attribute, condition, threshold)"
    },
    "points.filter_missing_invalid_attributes": {
        "name": "filter_missing_invalid_attributes",
        "category": "points",
        "signature": "(self, points, to_remove='')",
        "doc": "Filter a PointDataset ('points') by removing points that contain missing or invalid values ('to_remove') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered.\n\nto_remove (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.",
        "example": "result = tt.points.filter_missing_invalid_attributes(points, to_remove='')"
    },
    "points.filter_numeric_attribute": {
        "name": "filter_numeric_attribute",
        "category": "points",
        "signature": "(self, points, attribute, condition, threshold)",
        "doc": "Remove points from a PointDataset ('points') that do not meet a condition placed upon a numerical attribute ('attribute') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattribute (string): the point attribute to filter points by. Must be a header in the dataset for a numerical attribute.\n\ncondition (string): the condition placed upon the point attribute for removing points. May be specified as \"<\" for less than, \"<=\" for less than equal to, \">\" for greater than, \">=\" for greater than equal to, \"==\" for equal to, or \"!=\" for not equal to.\n\nthreshold (integer, float): the value to evaluate the condition against.",
        "example": "result = tt.points.filter_numeric_attribute(points, attribute, condition, threshold)"
    },
    "points.filter_text_attribute": {
        "name": "filter_text_attribute",
        "category": "points",
        "signature": "(self, points, attribute, condition, threshold)",
        "doc": "Filter a PointDataset ('points') by removing points that do not meet a specified threshold condition on a string (text) attribute, and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattribute (string): the point attribute to filter points by. Must be a header in the dataset for a string attribute.\n\ncondition (string): the condition placed upon the point attribute for removing points. May be specified as \"==\" for equal to, \"!=\" for not equal to, \"like\" for contains, \"not like\" for does not contain, \"start\" for starts with, \"not start\" for does not start with, \"end\" for ends with, or \"not end\" for does not end with. Conditions are case sensitive.\n\nthreshold (string): the value to evaluate the condition against.",
        "example": "result = tt.points.filter_text_attribute(points, attribute, condition, threshold)"
    },
    "points.filter_type_attribute": {
        "name": "filter_type_attribute",
        "category": "points",
        "signature": "(self, points, attribute, condition, dtype)",
        "doc": "Filter a PointDataset ('points') by removing points that do not meet a specified data type condition and return a new PointDataset. This filtering operation is performed with point attributes of specific data types.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattribute (string): the point attribute to filter points by. Must be a header in the dataset.\n\ncondition (string): the condition placed upon the point attribute for removing points. May be specified as \"is\" to include values that match the data type, or \"is not\" to include values that do not match.\n\ndtype (string): the data type to evaluate each value in the specified attribute against to determine inclusion in the filtered data. Possible types include \"int\", \"float\", \"string\", \"bool\", and \"nan\".",
        "example": "result = tt.points.filter_type_attribute(points, attribute, condition, dtype)"
    },
    "points.get_point": {
        "name": "get_point",
        "category": "points",
        "signature": "(self, points, id)",
        "doc": "Return a single Point object with the specified id ('id') from a PointDataset ('points').\n\nParameters:\n\npoint_dataset (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nid (integer, float, string): the unique identifier of the point to be returned.",
        "example": "result = tt.points.get_point(points, id)"
    },
    "points.interpolate_inverse_distance_weighted": {
        "name": "interpolate_inverse_distance_weighted",
        "category": "points",
        "signature": "(self, points, attr_name, radius, power=2, to_fill='', decimals=2)",
        "doc": "Interpolate a new value for each missing or invalid value ('to_fill') for a specified attribute ('attr_name') in a PointDataset ('points') using an inverse distance weighted (IDW) technique and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattr_name (string): the name of the attribute to interpolate. Only missing or invalid values will be interpolated.\n\nradius (integer, float): the distance to search around each point for other points to interpolate with. Only valid (numeric) values of points within this range will be used for interpolation.\n\npower (integer): the power of the inverse distance weighting function. Higher values will give greater weight to nearer values i.e. nearer values will contribute more strongly to the interpolated value.\n\nto_fill (integer, float, string, list): the value or list of values to be considered missing or invalid. The default is an empty string \"\" representing a missing value.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.points.interpolate_inverse_distance_weighted(points, attr_name, radius, power=2, to_fill='', decimals=2)"
    },
    "points.kmeans_cluster": {
        "name": "kmeans_cluster",
        "category": "points",
        "signature": "(self, points, k, attributes=['x', 'y'], convergence_threshold=1e-05, max_iterations=50)",
        "doc": "Cluster points in a PointDataset ('points') into k clusters using the k-means algorithm and return a new PointDataset with a 'cluster' attribute appended.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nk (integer): the number of clusters to generate. Must be less than or equal to the number of points.\n\nattributes (list): list of attribute headers to use for clustering. Must be numeric attributes. Must include at least two attributes.\n\nconvergence_threshold (float): the threshold for centroid movement to determine convergence.\n\nmax_iterations (integer): the maximum number of iterations to perform. ",
        "example": "result = tt.points.kmeans_cluster(points, k, attributes=['x', 'y'], convergence_threshold=1e-05, max_iterations=50)"
    },
    "points.mean_center": {
        "name": "mean_center",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Compute and return the mean center (average x and y coordinates) of a PointDataset ('points') as a tuple.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places output coordinates will be rounded to. Default is 2.",
        "example": "result = tt.points.mean_center(points, decimals=2)"
    },
    "points.medoid": {
        "name": "medoid",
        "category": "points",
        "signature": "(self, points)",
        "doc": "Compute and return the medoid (a central point that must belong to the set of input points) of a PointDataset ('points') as a Point object.\n\nParameters:\n\npoints (PointDataset): the dataset to analyze. The input dataset will not be altered by the operation.",
        "example": "result = tt.points.medoid(points)"
    },
    "points.nearest_neighbour": {
        "name": "nearest_neighbour",
        "category": "points",
        "signature": "(self, points1, points2, num_nearest=1, method='Euclidean', decimals=2)",
        "doc": "Compute the nearest neighbours of each point in an input PointDataset ('points1') from a second PointDataset ('points2') and return a new PointDataset with added headers and attributes for nearest neighbour IDs and distances.\n\nParameters:\n\npoints1 (object): the dataset to determine nearest neighbours of. The input dataset will not be altered by the operation.\n\npoints2 (object): the dataset to determine nearest neighbours from.\n\nnum_nearest (integer): the number of nearest neighbours to determine for each point.\n\nmethod (string): the method with which to calculate distance. Possible choices are 'Euclidean' and 'Manhattan'.\n\ndecimals (integer): the number of decimal places distance will be rounded to. Default is 2.",
        "example": "result = tt.points.nearest_neighbour(points1, points2, num_nearest=1, method='Euclidean', decimals=2)"
    },
    "points.new_point": {
        "name": "new_point",
        "category": "points",
        "signature": "(self, id, x, y, attr_name=None, attr=None)",
        "doc": "Return a new Point object with the specified unique identifier, x coordinate, y coordinate, and attributes.\n\nParameters:\n\nid (integer, float, string): the unique identifier of the point.\n\nx (integer, float): the x coordinate of the point.\n\ny (integer, float): the y coordinate of the point.\n\nattr_name (string, list): a string or list of strings representing the names of point attributes.\n\nattr (integer, float, string, list): the value or list of values representing the values of point attributes.",
        "example": "result = tt.points.new_point(id, x, y, attr_name=None, attr=None)"
    },
    "points.normalize_latitude": {
        "name": "normalize_latitude",
        "category": "points",
        "signature": "(self, points)",
        "doc": "Normalize latitude (y) values in a PointDataset ('points') to the range [-90, 90].\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered.",
        "example": "result = tt.points.normalize_latitude(points)"
    },
    "points.normalize_longitude": {
        "name": "normalize_longitude",
        "category": "points",
        "signature": "(self, points, mode='180')",
        "doc": "Normalize longitude (x) values in a PointDataset ('points') to either [-180, 180] or [0, 360].\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered.\n\nmode (string): '180' for range [-180, 180], '360' for range [0, 360]. Default is '180'.",
        "example": "result = tt.points.normalize_longitude(points, mode='180')"
    },
    "points.num_points_in_range": {
        "name": "num_points_in_range",
        "category": "points",
        "signature": "(self, points, radius)",
        "doc": "Calculate the number of points around each point in a PointDataset ('points') within a specified distance ('radius') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nradius (integer, float): the distance to search around each point for other points.",
        "example": "result = tt.points.num_points_in_range(points, radius)"
    },
    "points.point_density": {
        "name": "point_density",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Calculate the density of points (points per unit area) within the extent of a PointDataset ('points').\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places the density will be rounded to. Default is 2.",
        "example": "result = tt.points.point_density(points, decimals=2)"
    },
    "points.point_distribution": {
        "name": "point_distribution",
        "category": "points",
        "signature": "(self, points, iterations=100, decimals=2)",
        "doc": "Calculate and return an index of the spatial distribution (pDist) of a PointDataset ('points').\n\nThe pDist index compares the standard distance of the input dataset to the average standard distance\nof random point distributions within the same extent. Values < 0 indicate clustering, ~0 randomness,\nand > 0 dispersion.\n\nParameters:\n\npoints (object): the dataset to analyze. The input dataset will not be altered by the operation.\n\niterations (integer): number of random point distributions to generate for reference. Default is 100.\n\ndecimals (integer): number of decimal places to round values. Default is 2.",
        "example": "result = tt.points.point_distribution(points, iterations=100, decimals=2)"
    },
    "points.point_in_extent": {
        "name": "point_in_extent",
        "category": "points",
        "signature": "(self, point, extent)",
        "doc": "Determine if a specified Point object ('point') falls within the specified bounding box extent ('extent').\n\nParameters:\n\npoint (object): the Point object to test.\n\nextent (list, tuple): a list or tuple representing the extent in the format (min_x, min_y, max_x, max_y).",
        "example": "result = tt.points.point_in_extent(point, extent)"
    },
    "points.points_to_table": {
        "name": "points_to_table",
        "category": "points",
        "signature": "(self, points)",
        "doc": "Convert a PointDataset ('points') into a Table object.\n\nParameters:\n\npoints (object): the PointDataset to convert to a Table object.",
        "example": "result = tt.points.points_to_table(points)"
    },
    "points.reflect": {
        "name": "reflect",
        "category": "points",
        "signature": "(self, points, axis='x')",
        "doc": "Reflect all points in a PointDataset ('points') across a specified axis and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation..\n\naxis (string): the axis across which to reflect the points. Options are 'x' (mirror across x-axis), 'y' (mirror across y-axis), or 'origin' (mirror across both axes). Default is 'x'.",
        "example": "result = tt.points.reflect(points, axis='x')"
    },
    "points.remove_attribute": {
        "name": "remove_attribute",
        "category": "points",
        "signature": "(self, points, attr_name)",
        "doc": "Remove an attribute from each Point in a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nattr_name (string): the name of the attribute to remove.",
        "example": "result = tt.points.remove_attribute(points, attr_name)"
    },
    "points.remove_overlapping_points": {
        "name": "remove_overlapping_points",
        "category": "points",
        "signature": "(self, points, dist_thresh)",
        "doc": "Remove overlapping points from a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the dataset to process. The input dataset will not be altered by the operation.\n\ndist_thresh (int or float): the distance threshold to remove points by. Any point within the distance threshold of another point will be removed.",
        "example": "result = tt.points.remove_overlapping_points(points, dist_thresh)"
    },
    "points.remove_point": {
        "name": "remove_point",
        "category": "points",
        "signature": "(self, points, id)",
        "doc": "Remove a Point object with the specified id ('id') from a PointDataset ('points').\n\nParameters:\n\npoints (object): the PointDataset to remove the point from.\n\nid (integer, float, string): the unique identifier of the point to be removed.",
        "example": "tt.points.remove_point(points, id)"
    },
    "points.rename_attribute": {
        "name": "rename_attribute",
        "category": "points",
        "signature": "(self, points, old_name, new_name)",
        "doc": "Rename an attribute in a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nold_name (string): the current name of the attribute to rename.\n\nnew_name (string): the new name for the attribute.",
        "example": "result = tt.points.rename_attribute(points, old_name, new_name)"
    },
    "points.rotate": {
        "name": "rotate",
        "category": "points",
        "signature": "(self, points, angle, pivot_x=0.0, pivot_y=0.0)",
        "doc": "Rotate all points in a PointDataset ('points') around a specified pivot by a given angle (in degrees) and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nangle (integer, float): the rotation angle in degrees. Positive values rotate counterclockwise.\n\npivot_x (integer, float): the x coordinate of the pivot point. Default is 0.0.\n\npivot_y (integer, float): the y coordinate of the pivot point. Default is 0.0.",
        "example": "result = tt.points.rotate(points, angle, pivot_x=0.0, pivot_y=0.0)"
    },
    "points.sample_points": {
        "name": "sample_points",
        "category": "points",
        "signature": "(self, points, num_points)",
        "doc": "Return a random sample of points from a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nnum_points (integer): the number of points to randomly sample from the dataset.",
        "example": "result = tt.points.sample_points(points, num_points)"
    },
    "points.scale": {
        "name": "scale",
        "category": "points",
        "signature": "(self, points, x_factor=1.0, y_factor=1.0)",
        "doc": "Scale the x and y coordinates of a PointDataset ('points') by specified factors and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation. \n\nx_factor (integer, float): the factor to multiply the x coordinate of each point. Default is 1.0.\n\ny_factor (integer, float): the factor to multiply the y coordinate of each point. Default is 1.0.",
        "example": "result = tt.points.scale(points, x_factor=1.0, y_factor=1.0)"
    },
    "points.shear": {
        "name": "shear",
        "category": "points",
        "signature": "(self, points, x_shear=0.0, y_shear=0.0)",
        "doc": "Apply a shear transformation to all points in a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nx_shear (integer, float): shear factor applied in the x direction (skews x by a proportion of y). Default is 0.0.\n\ny_shear (integer, float): shear factor applied in the y direction (skews y by a proportion of x). Default is 0.0.",
        "example": "result = tt.points.shear(points, x_shear=0.0, y_shear=0.0)"
    },
    "points.spatial_join": {
        "name": "spatial_join",
        "category": "points",
        "signature": "(self, points, to_join, columns='all', radius=None)",
        "doc": "Join the data of one PointDataset ('points') with the data from another PointDataset ('to_join'), based on nearest neighbour spatial proximity. This join function is a left outer join, using a one-to-one nearest neighbour relationship only (i.e., other join types and relationships are not supported).\n\nParameters:\n\npoints (object): the PointDataset to join attributes onto. The input dataset will not be altered by the operation.\n\nto_join (object): the PointDataset to join from. Attributes from this dataset will be transferred.\n\ncolumns (list, string): a list of strings representing the attribute headers in 'to_join' to be joined to 'points'. May be specified as the string \"all\" to include all available attributes.\n\nradius (integer, float, None): optional parameter to only join points within a specified radius.",
        "example": "result = tt.points.spatial_join(points, to_join, columns='all', radius=None)"
    },
    "points.standard_distance": {
        "name": "standard_distance",
        "category": "points",
        "signature": "(self, points, decimals=2)",
        "doc": "Compute and return the standard distance (the average distance of each point from the mean center) of a PointDataset ('points').\n\nParameters:\n\npoints (object): the dataset to analyze. The input dataset will not be altered by the operation.\n\ndecimals (integer): the number of decimal places to round to. Default is 2.",
        "example": "result = tt.points.standard_distance(points, decimals=2)"
    },
    "points.swap_coordinates": {
        "name": "swap_coordinates",
        "category": "points",
        "signature": "(self, points)",
        "doc": "Switch the x and y coordinates in a PointDataset ('points') and return a new PointDataset.\n\nParameters:\n\npoints (points): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.",
        "example": "result = tt.points.swap_coordinates(points)"
    },
    "points.table_to_points": {
        "name": "table_to_points",
        "category": "points",
        "signature": "(self, table, id_col, x_col, y_col)",
        "doc": "Convert a Table object ('table') to a PointDataset containing Point objects. A column must be chosen for the unique identifier ('id_col'), x coordinate ('x_col'), and y coordinate ('y_col'). All other columns will be added as point attributes which are referenced by their column header.\n\nParameters:\n\ntable (object): the Table object to convert to a PointDataset.\n\nid_col (string): the header of the column that contains the unique identifier for each point.\n\nx_col (string): the header of the column that contains the x coordinate for each point.\n\ny_col (string): the header of the column that contains the y coordinate for each point.",
        "example": "result = tt.points.table_to_points(table, id_col, x_col, y_col)"
    },
    "points.translate": {
        "name": "translate",
        "category": "points",
        "signature": "(self, points, x_shift=0.0, y_shift=0.0)",
        "doc": "Displace the x and y coordinates of a PointDataset ('points') by a specified x and y offset distance and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\nx_shift (integer, float): the distance to displace the x coordinate of each point.\n\ny_shift (integer, float): the distance to displace the y coordinate of each point.",
        "example": "result = tt.points.translate(points, x_shift=0.0, y_shift=0.0)"
    },
    "points.translate_random_uniform": {
        "name": "translate_random_uniform",
        "category": "points",
        "signature": "(self, points, dist)",
        "doc": "Randomly displace the x and y coordinates of a PointDataset ('points') by a uniform random offset between -dist and +dist, and return a new PointDataset.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\ndist (integer, float): the maximum absolute distance to randomly displace the coordinates of each point.",
        "example": "result = tt.points.translate_random_uniform(points, dist)"
    },
    "points.unrotate_coordinates": {
        "name": "unrotate_coordinates",
        "category": "points",
        "signature": "(self, points, pole_x, pole_y)",
        "doc": "Unrotate the x and y coordinates in a PointDataset ('points') from a rotated pole coordinate system and return a new PointDataset. The x and y coordinates will be overwritten with the unrotated coordinates.\n\nParameters:\n\npoints (object): the PointDataset the operation will be performed on. The input dataset will not be altered by the operation.\n\npole_x (integer, float): the x coordinate of the pole about which the points will be rotated.\n\npole_y (integer, float): the y coordinate of the pole about which the points will be rotated.",
        "example": "result = tt.points.unrotate_coordinates(points, pole_x, pole_y)"
    },
    "points.unrotate_x": {
        "name": "unrotate_x",
        "category": "points",
        "signature": "(self, x, y, pole_x, pole_y)",
        "doc": "Unrotate a list of x coordinates ('x') from a rotated pole coordinate system and return a new list of x coordinates.\n\nParameters:\n\nx (list): the list of x coordinates the operation will be performed on. The input list will not be altered by the operation.\n\ny (list): the list of y coordinates required for the operation.\n\npole_x (integer, float): the x coordinate of the pole about which the x will be rotated.\n\npole_y (integer, float): the y coordinate of the pole about which the x will be rotated.",
        "example": "result = tt.points.unrotate_x(x, y, pole_x, pole_y)"
    },
    "points.unrotate_y": {
        "name": "unrotate_y",
        "category": "points",
        "signature": "(self, x, y, pole_x, pole_y)",
        "doc": "Unrotate a list of y coordinates ('y') from a rotated pole coordinate system and return a new list of y coordinates.\n\nParameters:\n\nx (list): the list of x coordinates required for the operation.\n\ny (list): the list of y coordinates the operation will be performed on. The input list will not be altered by the operation.\n\npole_x (integer, float): the x coordinate of the pole about which the y will be rotated.\n\npole_y (integer, float): the y coordinate of the pole about which the y will be rotated.",
        "example": "result = tt.points.unrotate_y(x, y, pole_x, pole_y)"
    },
    "points.weighted_mean_center": {
        "name": "weighted_mean_center",
        "category": "points",
        "signature": "(self, points, weight_attr, decimals=2)",
        "doc": "Compute and return the weighted mean center (average x and y coordinates weighted by an attribute) of a PointDataset ('points') as a tuple.\n\nParameters:\n\npoints (object): the dataset to analyze. The input dataset will not be altered by the operation.\n\nweight_attr (string): the point attribute to weigh each point's contribution to the mean center by. Must be a numerical attribute present in each point.\n\ndecimals (integer): the number of decimal places coordinates will be rounded to. Default is 2.",
        "example": "result = tt.points.weighted_mean_center(points, weight_attr, decimals=2)"
    },
    "points.weighted_standard_distance": {
        "name": "weighted_standard_distance",
        "category": "points",
        "signature": "(self, points, weight_attr, decimals=2)",
        "doc": "Compute and return the weighted standard distance (the average distance of each point from the weighted mean center) of a PointDataset ('points').\n\nParameters:\n\npoints (object): the dataset to analyze. The input dataset will not be altered by the operation.\n\nweight_attr (string): the point attribute to weigh each point's contribution to the mean center by. Must be a numerical attribute present in each point.\n\ndecimals (integer): the number of decimal places to round to. Default is 2.",
        "example": "result = tt.points.weighted_standard_distance(points, weight_attr, decimals=2)"
    },
    "stats": {
        "name": "stats",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing statistical operations on lists of numerical values.",
        "functions": [
            "binary_stats",
            "chi_square",
            "chi_square_independence",
            "ci_difference_of_means",
            "ci_mean",
            "ci_proportion",
            "ci_regression_slope",
            "contingency_table",
            "cramers_v",
            "cumulative_distribution",
            "cumulative_mass_function",
            "descriptive_stat",
            "display_toolbox_functions",
            "effect_size_d_g",
            "f_test",
            "get_random_sample",
            "k_most_common",
            "kendall_tau",
            "kruskal_wallis",
            "linear_regression",
            "linear_regression_predict",
            "loess",
            "lowess",
            "mann_whitney",
            "mean_absolute_error",
            "mean_square_error",
            "multiple_linear_regression",
            "multiple_regression_predict",
            "odds_ratio",
            "one_proportion_z_test",
            "one_sample_t_test",
            "one_way_anova",
            "paired_t_test",
            "pearson_correlation",
            "phi_coefficient",
            "probability_distribution",
            "relative_risk",
            "remove_beyond_iqr",
            "remove_beyond_std",
            "root_mean_square_error",
            "single_freq",
            "spearman_rank_correlation",
            "standardize",
            "summary_stats",
            "two_proportion_z_test",
            "unique_freq",
            "unpaired_t_test",
            "vif",
            "welch_t_test",
            "wilcoxon_signed_rank"
        ],
        "example": "result = tt.stats.binary_stats(predicted, observed, beta=1, decimals=2)"
    },
    "stats.binary_stats": {
        "name": "binary_stats",
        "category": "stats",
        "signature": "(self, predicted, observed, beta=1, decimals=2)",
        "doc": "Calculate and return binary classification statistics for lists of predicted ('predicted') and observed ('observed') values. Returns a dictionary with the following keys: recall, precision, accuracy, f1_score, phi_coefficient, confusion_matrix (a dictionary of TP, FP, TN, FN), fbeta_score, balanced_accuracy, negative_predictive_value, specificity, and kappa.\n\nParameters:\n\npredicted (list): the list of binary values (1/0 or True/False) representing the data produced by a classification technique. The input list will not be altered by the operation.\n\nobserved (list): the list of binary values (1/0 or True/False) representing the observed data to compare the classification technique against. The input list will not be altered by the operation.\n\nbeta (float): the beta parameter for the F-beta score (default is 1 for F1).\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.binary_stats(predicted, observed, beta=1, decimals=2)"
    },
    "stats.chi_square": {
        "name": "chi_square",
        "category": "stats",
        "signature": "(self, vals, alpha=0.05, decimals=2)",
        "doc": "Calculate the Chi-squared value for an input list ('vals'). Returns a dictionary containing the chi-squared statistic (key: chi_square), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the chi-square test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.chi_square(vals, alpha=0.05, decimals=2)"
    },
    "stats.chi_square_independence": {
        "name": "chi_square_independence",
        "category": "stats",
        "signature": "(self, c_table, alpha=0.05, decimals=2)",
        "doc": "Perform a Chi-Square Test of Independence on a contingency table represented by a nested list. Returns a dictionary containing the chi-square statistic (key: chi_square), degrees of freedom (key: df), expected frequencies (key: expected), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nc_table (list): a nested list representing the numeric contingency matrix. This should be the 'c_table' value extracted from the dictionary returned by the contingency_table() function, not the full dictionary itself.\n\nalpha (float): the significance level for the chi-square test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.chi_square_independence(c_table, alpha=0.05, decimals=2)"
    },
    "stats.ci_difference_of_means": {
        "name": "ci_difference_of_means",
        "category": "stats",
        "signature": "(self, vals1, vals2, alpha=0.05, decimals=2)",
        "doc": "Calculate a confidence interval for the difference of means between two independent samples ('vals1' and 'vals2') using Welch's method. Returns a dictionary with the following keys:  difference, lower, upper, and margin_of_error.\n\nParameters:\n\nvals1 (list): the list of numeric values representing the first sample. The input list will not be altered by the operation.\n\nvals2 (list): the list of numeric values representing the second sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the confidence interval.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.ci_difference_of_means(vals1, vals2, alpha=0.05, decimals=2)"
    },
    "stats.ci_mean": {
        "name": "ci_mean",
        "category": "stats",
        "signature": "(self, vals, alpha=0.05, decimals=2)",
        "doc": "Calculate a confidence interval for the mean of a numeric sample ('vals'). Returns a dictionary with the following keys: mean, lower, upper, and margin_of_error.\n\nParameters:\n\nvals (list): the list of numeric values representing the sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the confidence interval.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.ci_mean(vals, alpha=0.05, decimals=2)"
    },
    "stats.ci_proportion": {
        "name": "ci_proportion",
        "category": "stats",
        "signature": "(self, vals, alpha=0.05, decimals=2)",
        "doc": "Calculate a confidence interval for a proportion based on a binary sample ('vals'). Returns a dictionary with the following keys: proportion, lower, upper, and margin_of_error.\n\nParameters:\n\nvals (list): the list of binary values (1/0 or True/False) representing the sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the confidence interval.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.ci_proportion(vals, alpha=0.05, decimals=2)"
    },
    "stats.ci_regression_slope": {
        "name": "ci_regression_slope",
        "category": "stats",
        "signature": "(self, slope, std_error, df, alpha=0.05, decimals=2)",
        "doc": "Calculate a confidence interval for a regression slope ('slope') using its standard error ('std_error') and degrees of freedom ('df'). Returns a dictionary with the following keys: slope, lower, upper,  and margin_of_error.\n\nParameters:\n\nslope (float): the estimated regression slope coefficient.\n\nstd_error (float): the standard error associated with the slope estimate.\n\ndf (integer or float): the degrees of freedom for the regression model.\n\nalpha (float): the significance level for the confidence interval.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.ci_regression_slope(slope, std_error, df, alpha=0.05, decimals=2)"
    },
    "stats.contingency_table": {
        "name": "contingency_table",
        "category": "stats",
        "signature": "(self, x_var, y_var, sort=True)",
        "doc": "Construct a contingency table (cross-tabulation) from two categorical variables of equal length. Returns a dictionary containing the contingency table (key: c_table), row labels (key: row_labels), and column labels (key: col_labels).\n\nParameters:\n\nx_var (list): the list of categorical values representing the first variable. The input list will not be altered by the operation.\n\ny_var (list): the list of categorical values representing the second variable. The input list will not be altered by the operation.\n\nsort (bool): if True, categories are sorted alphabetically. If False, they appear in the order of first occurrence.",
        "example": "result = tt.stats.contingency_table(x_var, y_var, sort=True)"
    },
    "stats.cramers_v": {
        "name": "cramers_v",
        "category": "stats",
        "signature": "(self, c_table, decimals=2)",
        "doc": "Calculate Cram\u00e9r's V (effect size) for any r x c contingency table and return a dictionary containing V (key: cramers_v), chi-square (key: chi_square), degrees of freedom (key: df), and sample size (key: n).\n\nParameters:\n\nc_table (list): a nested list representing the numeric contingency matrix. This should be the 'c_table' value extracted from the dictionary returned by the contingency_table() function, not the full dictionary itself.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.cramers_v(c_table, decimals=2)"
    },
    "stats.cumulative_distribution": {
        "name": "cumulative_distribution",
        "category": "stats",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the cumulative distribution function for an input list ('vals'). Returns a dictionary containing the sorted values (key: values), their probabilities (key: probabilities), the cumulative distribution (key: cdf), and the total number of observations (key: total).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.cumulative_distribution(vals, decimals=2)"
    },
    "stats.cumulative_mass_function": {
        "name": "cumulative_mass_function",
        "category": "stats",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the cumulative mass function for an input list ('vals)'. Returns a dictionary containing the cumulative values (key: cumulative_values), the normalized cumulative mass function (key: cmf), and the total sum of values (key: total).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.cumulative_mass_function(vals, decimals=2)"
    },
    "stats.descriptive_stat": {
        "name": "descriptive_stat",
        "category": "stats",
        "signature": "(self, vals, stat, decimals=2)",
        "doc": "Calculate and return the specified descriptive statistic ('stat') of the input list ('vals').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nstat (string): the specific statistic to return. Possible statistics are \"Count\", \"Unique Values\", \"First\", \"Last\", \"Sum\", \"Max\", \"Min\", \"Range\", \"Mean\", \"Median\", \"Mode\", \"IQ1\", \"IQ3\", \"IQR\", \"Standard Deviation\", \"Standard Error\", \"Variance\", \"Coefficient of Variation\", \"Skewness\", and \"Kurtosis\"\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.descriptive_stat(vals, stat, decimals=2)"
    },
    "stats.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "stats",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.stats.display_toolbox_functions()"
    },
    "stats.effect_size_d_g": {
        "name": "effect_size_d_g",
        "category": "stats",
        "signature": "(self, group1, group2, decimals=2)",
        "doc": "Calculate and return Cohen's d and Hedges' g for two independent groups ('group1' and 'group2').  Returns a dictionary with the following keys: cohens_d and hedges_g.\n\nParameters:\n\ngroup1 (list): the list of numeric values representing the first group. The input list will not be altered by the operation.\n\ngroup2 (list): the list of numeric values representing the second group. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.effect_size_d_g(group1, group2, decimals=2)"
    },
    "stats.f_test": {
        "name": "f_test",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Perform an F-test to compare the variances of two independent samples ('x_var', 'y_var'). Returns a dictionary containing the F-statistic (key: f_stat), degrees of freedom for both samples (key: df1, key: df2), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of numeric values representing the first sample. The input list will not be altered by the operation.\n\ny_var (list): the list of numeric values representing the second sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the F-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.f_test(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.get_random_sample": {
        "name": "get_random_sample",
        "category": "stats",
        "signature": "(self, vals, num_samples)",
        "doc": "Return a new list containing a specified number of random samples ('num_samples') from the input list ('vals'), without replacement.\n\nParameters:\n\nvals (list): the list of values to draw random samples from. The input list will not be altered by the operation.\n\nnum_samples (integer): the number of random samples to draw from the given list.",
        "example": "result = tt.stats.get_random_sample(vals, num_samples)"
    },
    "stats.k_most_common": {
        "name": "k_most_common",
        "category": "stats",
        "signature": "(self, vals, k)",
        "doc": "Determine the unique values in the input list ('vals') and return the k most frequent values.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nk (integer): the number of most frequent values to return.",
        "example": "result = tt.stats.k_most_common(vals, k)"
    },
    "stats.kendall_tau": {
        "name": "kendall_tau",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Compute Kendall's Tau-b correlation coefficient for two numeric variables ('x_var', 'y_var'). Returns a dictionary containing tau (key: tau), the Z statistic (key: z_stat), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of numeric values representing the first variable. The input list will not be altered by the operation.\n\ny_var (list): the list of numeric values representing the second variable. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the Kendall test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.kendall_tau(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.kruskal_wallis": {
        "name": "kruskal_wallis",
        "category": "stats",
        "signature": "(self, groups, alpha=0.05, decimals=2)",
        "doc": "Perform a Kruskal-Wallis H test on k independent samples. Returns a dictionary containing the H-statistic (key: h_stat), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\ngroups (list): a nested list where each element is a list of numeric values representing one independent sample. The input lists will not be altered by the operation.\n\nalpha (float): the significance level for the Kruskal-Wallis test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.kruskal_wallis(groups, alpha=0.05, decimals=2)"
    },
    "stats.linear_regression": {
        "name": "linear_regression",
        "category": "stats",
        "signature": "(self, x_var, y_var, decimals=2)",
        "doc": "Calculate the equation of the regression line between an independent variable ('x_var') and a dependent variable ('y_var'). Returns a dictionary containing the intercept (key: intercept), slope (key: slope), r-squared (key: r_squared), standard error (key: std_error), and residuals (key: residuals).\n\nParameters:\n\nx_var (list): the list of values representing the independent variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the dependent variable the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.linear_regression(x_var, y_var, decimals=2)"
    },
    "stats.linear_regression_predict": {
        "name": "linear_regression_predict",
        "category": "stats",
        "signature": "(self, x_values, model, decimals=2)",
        "doc": "Generate predicted y-values using a linear regression model.\n\nParameters:\n\nx_values (list): the list of independent variable values to generate predictions for. The input list will not be altered by the operation.\n\nmodel (dict): a dictionary returned by the linear_regression function containing at least the keys \"intercept\" and \"slope\".\n\ndecimals (integer): the number of decimal places predicted values will be rounded to.",
        "example": "result = tt.stats.linear_regression_predict(x_values, model, decimals=2)"
    },
    "stats.loess": {
        "name": "loess",
        "category": "stats",
        "signature": "(self, x_vals, y_vals, fraction=0.3, degree=2, alpha=0.05, decimals=2)",
        "doc": "Perform LOESS (Locally Estimated Scatterplot Smoothing) on paired data ('x_vals', 'y_vals'), returning smoothed values and confidence bands. Returns a dictionary with the following keys: x, y_smooth, standard_error, lower, and upper.\n\nParameters:\n\nx_vals (list): the list of x-values. The input list will not be altered by the operation.\n\ny_vals (list): the list of y-values corresponding to x_vals. The input list will not be altered by the operation.\n\nfraction (float): the fraction of the data used in each local regression (smoothing parameter).\n\ndegree (integer): the degree of the local polynomial (0, 1, or 2). Default is 2 (quadratic LOESS).\n\nalpha (float): the significance level for the confidence interval.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.loess(x_vals, y_vals, fraction=0.3, degree=2, alpha=0.05, decimals=2)"
    },
    "stats.lowess": {
        "name": "lowess",
        "category": "stats",
        "signature": "(self, x_vals, y_vals, fraction=0.3, decimals=2)",
        "doc": "Perform LOWESS (Locally Weighted Scatterplot Smoothing) on paired data ('x_vals', 'y_vals'). Returns a dictionary with the following keys: x and y_smooth.\n\nParameters:\n\nx_vals (list): the list of x-values. The input list will not be altered by the operation.\n\ny_vals (list): the list of y-values corresponding to x_vals. The input list will not be altered.\n\nfraction (float): the fraction of the data used in each local regression (smoothing parameter).\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.lowess(x_vals, y_vals, fraction=0.3, decimals=2)"
    },
    "stats.mann_whitney": {
        "name": "mann_whitney",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Perform a Mann-Whitney U test on two independent samples ('x_var', 'y_var'). Returns a dictionary containing the U statistic (key: U), the Z statistic (key: z_stat), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of numeric values representing the first sample. The input list will not be altered by the operation.\n\ny_var (list): the list of numeric values representing the second sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the Mann-Whitney test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.mann_whitney(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.mean_absolute_error": {
        "name": "mean_absolute_error",
        "category": "stats",
        "signature": "(self, predicted, observed, decimals=2)",
        "doc": "Calculate and return the mean absolute error for input lists of predicted ('predicted') and observed ('observed') values.\n\nParameters:\n\npredicted (list): the list of predicted values the operation will be performed on. The input list will not be altered by the operation.\n\nobserved (list): the list of observed values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.mean_absolute_error(predicted, observed, decimals=2)"
    },
    "stats.mean_square_error": {
        "name": "mean_square_error",
        "category": "stats",
        "signature": "(self, predicted, observed, decimals=2)",
        "doc": "Calculate and return the mean square error for input lists of predicted ('predicted') and observed ('observed') values.\n\nParameters:\n\npredicted (list): the list of predicted values the operation will be performed on. The input list will not be altered by the operation.\n\nobserved (list): the list of observed values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.mean_square_error(predicted, observed, decimals=2)"
    },
    "stats.multiple_linear_regression": {
        "name": "multiple_linear_regression",
        "category": "stats",
        "signature": "(self, x_vars, y_var, decimals=2)",
        "doc": "Perform multiple linear regression using a list of predictor variables ('x_vars') and a dependent variable ('y_var'). Returns a dictionary containing the intercept (key: intercept), coefficients (key: coefficients), slope (key: slope), r-squared (key: r_squared), standard error (key: std_error), and residuals (key: residuals), as well as adjusted r-squared (key: adjusted_r_squared), an ANOVA table (key: anova), and coefficient-level t-test results (key: coefficients_significance).\n\nParameters:\n\nx_vars (list): a nested list where each sub-list represents one independent variable the operation will be performed on. All predictor lists must be the same length. The input list will not be altered by the operation\n\ny_var (list): the list of values representing the dependent variable the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.multiple_linear_regression(x_vars, y_var, decimals=2)"
    },
    "stats.multiple_regression_predict": {
        "name": "multiple_regression_predict",
        "category": "stats",
        "signature": "(self, x_vars, model, decimals=2)",
        "doc": "Generate predicted y-values using a multiple linear regression model.\n\nParameters:\n\nx_vars (list): a nested list where each sub-list represents one independent variable to generate predictions for. All predictor lists must be the same length. The input list will not be altered by the operation.\n\nmodel (dict): a dictionary returned by the multiple_linear_regression function containing the keys 'intercept' and 'coefficients'.\n\ndecimals (integer): number of decimal places to round returned values to.",
        "example": "result = tt.stats.multiple_regression_predict(x_vars, model, decimals=2)"
    },
    "stats.odds_ratio": {
        "name": "odds_ratio",
        "category": "stats",
        "signature": "(self, c_table, decimals=2)",
        "doc": "Calculate the Odds Ratio for a 2x2 contingency table and return a dictionary containing odds_ratio (key: odds_ratio).\n\nParameters:\n\nc_table (list): a nested list representing the numeric contingency matrix. This should be the 'c_table' value extracted from the dictionary returned by the contingency_table() function, not the full dictionary itself.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.odds_ratio(c_table, decimals=2)"
    },
    "stats.one_proportion_z_test": {
        "name": "one_proportion_z_test",
        "category": "stats",
        "signature": "(self, successes, n, p0, alpha=0.05, decimals=2)",
        "doc": "Perform a one-proportion Z test to compare an observed proportion (successes / n) against a theoretical proportion (p0). Returns a dictionary containing the z-statistic (key: z_stat), degrees of freedom used for lookup (key: df_used), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nsuccesses (integer): the number of observed successes.\n\nn (integer): the total number of trials.\n\np0 (float): the theoretical population proportion.\n\nalpha (float): the significance level for the z-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.one_proportion_z_test(successes, n, p0, alpha=0.05, decimals=2)"
    },
    "stats.one_sample_t_test": {
        "name": "one_sample_t_test",
        "category": "stats",
        "signature": "(self, vals, mu, alpha=0.05, decimals=2)",
        "doc": "Calculate the one-sample T value for an input list ('val's) to test for a difference of the mean from a theoretical mean ('mu'). Returns a dictionary containing the t-statistic (key: t_stat), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmu (integer,float): the theoretical mean.\n\nalpha (float): the significance level for the t-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.one_sample_t_test(vals, mu, alpha=0.05, decimals=2)"
    },
    "stats.one_way_anova": {
        "name": "one_way_anova",
        "category": "stats",
        "signature": "(self, groups, alpha=0.05, decimals=2)",
        "doc": "Perform a one-way ANOVA test on k independent samples. Returns a dictionary containing the F-statistic (key: f_stat), degrees of freedom for between-group and within-group variation (key: df_between, key: df_within), significance decision (key: significance), the critical value used (key: critical_value), as well as eta-squared (key: eta_squared) and omega-squared (key: omega_squared).\n\nParameters:\n\ngroups (list): a nested list where each element is a list of numeric values representing one independent sample. The input lists will not be altered by the operation.\n\nalpha (float): the significance level for the ANOVA test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.one_way_anova(groups, alpha=0.05, decimals=2)"
    },
    "stats.paired_t_test": {
        "name": "paired_t_test",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Calculate the paired-samples T value for two dependent variables ('x_var', 'y_var') to test for a difference of means. Returns a dictionary containing the t-statistic (key: t_stat), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of values representing the x variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the y variable the operation will be performed on. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the t-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.paired_t_test(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.pearson_correlation": {
        "name": "pearson_correlation",
        "category": "stats",
        "signature": "(self, x_var, y_var, decimals=2)",
        "doc": "Calculate and return Pearson's correlation coefficient between an x variable (x_var) and a y variable (y_var). Returns a dictionary containing the correlation coefficient (key: correlation) and covariance (key: covariance).\n\nParameters:\n\nx_var (list): the list of values representing the x variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the y variable the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.pearson_correlation(x_var, y_var, decimals=2)"
    },
    "stats.phi_coefficient": {
        "name": "phi_coefficient",
        "category": "stats",
        "signature": "(self, c_table, decimals=2)",
        "doc": "Calculate the Phi coefficient (effect size) for a 2x2 contingency table and return a dictionary containing phi (key: phi) and total sample size (key: n)\n\nParameters:\n\nc_table (list): a nested list representing the numeric contingency matrix. This should be the 'c_table' value extracted from the dictionary returned by the contingency_table() function, not the full dictionary itself.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.phi_coefficient(c_table, decimals=2)"
    },
    "stats.probability_distribution": {
        "name": "probability_distribution",
        "category": "stats",
        "signature": "(self, vals)",
        "doc": "Calculate the probability distribution for an input list (vals). Returns a dictionary containing the unique values (key: values), their counts (key: counts), their probabilities (key: probabilities), and the total number of observations (key: total).\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.stats.probability_distribution(vals)"
    },
    "stats.relative_risk": {
        "name": "relative_risk",
        "category": "stats",
        "signature": "(self, c_table, decimals=2)",
        "doc": "Calculate the Relative Risk for a 2x2 contingency table and return a dictionary containing relative_risk (key: relative_risk).\n\nParameters:\n\nc_table (list): a nested list representing the numeric contingency matrix. This should be the 'c_table' value extracted from the dictionary returned by the contingency_table() function, not the full dictionary itself.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.relative_risk(c_table, decimals=2)"
    },
    "stats.remove_beyond_iqr": {
        "name": "remove_beyond_iqr",
        "category": "stats",
        "signature": "(self, vals)",
        "doc": "Remove values from an input list ('vals') that fall outside of the interquartile range and return a new list. Can be used for outlier removal.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.stats.remove_beyond_iqr(vals)"
    },
    "stats.remove_beyond_std": {
        "name": "remove_beyond_std",
        "category": "stats",
        "signature": "(self, vals, std_devs, decimals=2)",
        "doc": "Remove values from an input list ('vals') that fall outside of the specified number of standard deviations (std_devs) and return a new list. Can be used for outlier removal.\n\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nstd_dev (integer): the number of standard deviations to remove values by.\n\ndecimals (integer): the number of decimal places the mean and standard deviation will be calculated to.",
        "example": "result = tt.stats.remove_beyond_std(vals, std_devs, decimals=2)"
    },
    "stats.root_mean_square_error": {
        "name": "root_mean_square_error",
        "category": "stats",
        "signature": "(self, predicted, observed, decimals=2)",
        "doc": "Calculate and return the root-mean-square-error for input lists of predicted ('predicted') and observed ('observed') values.\n\nParameters:\n\npredicted (list): the list of predicted values the operation will be performed on. The input list will not be altered by the operation.\n\nobserved (list): the list of observed values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.root_mean_square_error(predicted, observed, decimals=2)"
    },
    "stats.single_freq": {
        "name": "single_freq",
        "category": "stats",
        "signature": "(self, vals, value)",
        "doc": "Calculate and return the frequency with which a specified value ('value') appears in the input list ('vals').\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nvalue (integer, float, string): the value to determine the frequency of.",
        "example": "result = tt.stats.single_freq(vals, value)"
    },
    "stats.spearman_rank_correlation": {
        "name": "spearman_rank_correlation",
        "category": "stats",
        "signature": "(self, x_var, y_var, decimals=2)",
        "doc": "Calculate and return the Spearman Rank-Order Correlation Coefficient between an x variable ('x_var') and a y variable ('y_var').\n\nParameters:\n\nx_var (list): the list of values representing the ranked x variable the operation will be performed on. Values must be integers. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the ranked y variable the operation will be performed on. Values must be integers. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.spearman_rank_correlation(x_var, y_var, decimals=2)"
    },
    "stats.standardize": {
        "name": "standardize",
        "category": "stats",
        "signature": "(self, vals, decimals=2)",
        "doc": "Calculate the z-score, or standard score, of each value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.standardize(vals, decimals=2)"
    },
    "stats.summary_stats": {
        "name": "summary_stats",
        "category": "stats",
        "signature": "(self, vals, terminal=False, decimals=2)",
        "doc": "Calculate and display all descriptive statistics of the input list ('vals') and return a dictionary of all statistics.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nterminal (Boolean): flag to indicate if the result will be printed to a terminal or just returned.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.summary_stats(vals, terminal=False, decimals=2)"
    },
    "stats.two_proportion_z_test": {
        "name": "two_proportion_z_test",
        "category": "stats",
        "signature": "(self, successes1, n1, successes2, n2, alpha=0.05, decimals=2)",
        "doc": "Perform a two-proportion Z test to compare the proportions of two independent samples. Returns a dictionary containing the z-statistic (key: z_stat), degrees of freedom used for lookup (key: df_used), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nsuccesses1 (integer): number of successes in sample 1.\n\nn1 (integer): total trials in sample 1.\n\nsuccesses2 (integer): number of successes in sample 2.\n\nn2 (integer): total trials in sample 2.\n\nalpha (float): the significance level for the z-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.two_proportion_z_test(successes1, n1, successes2, n2, alpha=0.05, decimals=2)"
    },
    "stats.unique_freq": {
        "name": "unique_freq",
        "category": "stats",
        "signature": "(self, vals)",
        "doc": "Determine the unique values in the input list ('vals') and calculate the frequency with which each unique value appears. Two lists are returned: a list of unique values and a list of unique value frequencies.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.stats.unique_freq(vals)"
    },
    "stats.unpaired_t_test": {
        "name": "unpaired_t_test",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Calculate the unpaired (independent samples) T value for two variables ('x_var', 'y_var') to test for a difference of means. Returns a dictionary containing the t-statistic (key: t_stat), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of values representing the x variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the y variable the operation will be performed on. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the t-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.unpaired_t_test(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.vif": {
        "name": "vif",
        "category": "stats",
        "signature": "(self, predictors, predictor_names=None, decimals=2)",
        "doc": "Calculate Variance Inflation Factors (VIF) for a set of predictor variables. Returns a dictionary mapping each predictor to its VIF value.\n\nParameters:\n\npredictors (list): a nested list where each element is a list of numeric values representing one predictor variable. All predictors must be the same length.\n\npredictor_names (list): optional list of names corresponding to each predictor. If None, predictors will be labeled by index.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.vif(predictors, predictor_names=None, decimals=2)"
    },
    "stats.welch_t_test": {
        "name": "welch_t_test",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Calculate Welch's two-sample T value for two independent variables (x_var, y_var) without assuming equal variances. Returns a dictionary containing the t-statistic (key: t_stat), degrees of freedom (key: df), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of values representing the x variable the operation will be performed on. The input list will not be altered by the operation.\n\ny_var (list): the list of values representing the y variable the operation will be performed on. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the t-test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.welch_t_test(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "stats.wilcoxon_signed_rank": {
        "name": "wilcoxon_signed_rank",
        "category": "stats",
        "signature": "(self, x_var, y_var, alpha=0.05, decimals=2)",
        "doc": "Perform a Wilcoxon Signed-Rank Test on two paired samples ('x_var', 'y_var'). Returns a dictionary containing the W statistic (key: W), the Z statistic (key: z_stat), significance decision (key: significance), and the critical value used (key: critical_value).\n\nParameters:\n\nx_var (list): the list of numeric values representing the first paired sample. The input list will not be altered by the operation.\n\ny_var (list): the list of numeric values representing the second paired sample. The input list will not be altered by the operation.\n\nalpha (float): the significance level for the Wilcoxon test.\n\ndecimals (integer): the number of decimal places float values will be rounded to.",
        "example": "result = tt.stats.wilcoxon_signed_rank(x_var, y_var, alpha=0.05, decimals=2)"
    },
    "symbols": {
        "name": "symbols",
        "category": "category",
        "signature": "",
        "doc": "A symbol class object to hold useful text symbols to include in strings.",
        "functions": [],
        "example": ""
    },
    "text": {
        "name": "text",
        "category": "category",
        "signature": "",
        "doc": "A set of functions for performing operations on lists of string (text) data.",
        "functions": [
            "capitalize",
            "case",
            "char_at_index",
            "concatenate",
            "contains",
            "count_str",
            "display_toolbox_functions",
            "extract_substring",
            "find_all",
            "index_of_char",
            "is_type",
            "join_strings",
            "length",
            "match_position",
            "pad",
            "remove_whitespace",
            "replace",
            "reverse",
            "split",
            "strip",
            "to_list",
            "trim",
            "truncate"
        ],
        "example": "result = tt.text.capitalize(vals)"
    },
    "text.capitalize": {
        "name": "capitalize",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Convert the first character of each text value from the input list ('vals ') to upper case and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.capitalize(vals)"
    },
    "text.case": {
        "name": "case",
        "category": "text",
        "signature": "(self, vals, mode='upper')",
        "doc": "Convert text values from the input list ('vals') to the specified case and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmode (string): the case conversion mode. Possible values are \"upper\" to convert to upper case, and \"lower\" to convert to lower case.",
        "example": "result = tt.text.case(vals, mode='upper')"
    },
    "text.char_at_index": {
        "name": "char_at_index",
        "category": "text",
        "signature": "(self, vals, index)",
        "doc": "Find the character at the specified index ('index') of each text value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nindex (integer): the index of the character to return from each text value of the input list. If 'index' is not within the valid range for a text value, a value of None will be returned for that element.",
        "example": "result = tt.text.char_at_index(vals, index)"
    },
    "text.concatenate": {
        "name": "concatenate",
        "category": "text",
        "signature": "(self, vals, list_or_string)",
        "doc": "Concatenate each text value of the input list ('vals') with either a specified string ('list_or_string') or the correspondong values of a second list ('list_or_string') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nlist_or_string (string, list): the list of corresponding text values or specified string to concatenate with the input list.",
        "example": "result = tt.text.concatenate(vals, list_or_string)"
    },
    "text.contains": {
        "name": "contains",
        "category": "text",
        "signature": "(self, vals, substr)",
        "doc": "Check whether each text value in the input list ('vals') contains the specified substring ('substr') and return a new list of booleans.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsubstr (string): the case-sensitive substring to search for. Must be a non-empty string.",
        "example": "result = tt.text.contains(vals, substr)"
    },
    "text.count_str": {
        "name": "count_str",
        "category": "text",
        "signature": "(self, vals, substr)",
        "doc": "Count the frequency of occurrence of a specified substring or character ('substr') in each text value of an input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsubstr (string): the case-sensitive substring or character to determine the count of.",
        "example": "result = tt.text.count_str(vals, substr)"
    },
    "text.display_toolbox_functions": {
        "name": "display_toolbox_functions",
        "category": "text",
        "signature": "(self)",
        "doc": "Display a list of all available functions within this toolbox.",
        "example": "tt.text.display_toolbox_functions()"
    },
    "text.extract_substring": {
        "name": "extract_substring",
        "category": "text",
        "signature": "(self, vals, start, end=None)",
        "doc": "Extract a substring from each text value in the input list ('vals') using the specified start and end indices, and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nstart (integer): the starting index (inclusive) of the substring.\n\nend (integer): the ending index (exclusive) of the substring. If None, the substring extends to the end of the text value.",
        "example": "result = tt.text.extract_substring(vals, start, end=None)"
    },
    "text.find_all": {
        "name": "find_all",
        "category": "text",
        "signature": "(self, vals, substr)",
        "doc": "Find all indices where the specified substring ('substr') occurs in each text value of the input list ('vals'), and return a nested list of indices.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsubstr (string): the case-sensitive substring to search for. Must be a non-empty string.",
        "example": "result = tt.text.find_all(vals, substr)"
    },
    "text.index_of_char": {
        "name": "index_of_char",
        "category": "text",
        "signature": "(self, vals, char)",
        "doc": "Find the index of the first occurrence of a specified character ('char') in each text value of the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nchar (string): the case-sensitive character to search for. Must be a non-empty string of length 1. Only the index of the first occurrence will be returned. If the character is not found, a value of None will be returned for that element.",
        "example": "result = tt.text.index_of_char(vals, char)"
    },
    "text.is_type": {
        "name": "is_type",
        "category": "text",
        "signature": "(self, vals, mode='alpha')",
        "doc": "Check whether each text value in the input list ('vals') matches the specified type ('mode'), and return a new list of booleans.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nmode (string, optional): the type of check to perform. Possible values are \"alpha\" to check if all characters are alphabetic, \"digit\" to check if all characters are digits, and \"alnum\" to check if all characters are alphanumeric.",
        "example": "result = tt.text.is_type(vals, mode='alpha')"
    },
    "text.join_strings": {
        "name": "join_strings",
        "category": "text",
        "signature": "(self, vals, sep='')",
        "doc": "Join all text values in the input list ('vals') into a single string, with an optional separator ('sep') and return a single string.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsep (string): the separator to insert between each text value. Defaults to an empty string.",
        "example": "result = tt.text.join_strings(vals, sep='')"
    },
    "text.length": {
        "name": "length",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Calculate the length of each text value of the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.length(vals)"
    },
    "text.match_position": {
        "name": "match_position",
        "category": "text",
        "signature": "(self, vals, substr, mode='start')",
        "doc": "Check whether each text value in the input list ('vals') starts or ends with the specified substring ('substr'), depending on the chosen mode, and return a new list of booleans.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsubstr (string): the case-sensitive substring to check for. Must be a non-empty string.\n\nmode (string): the position to check. Possible values are \"start\" to check if each text value starts with 'substr', and \"end\" to check if each text value ends with 'substr'.",
        "example": "result = tt.text.match_position(vals, substr, mode='start')"
    },
    "text.pad": {
        "name": "pad",
        "category": "text",
        "signature": "(self, vals, length, char=' ', mode='right')",
        "doc": "Pad each text value in the input list ('vals') with the specified character ('char') until it reaches the target length ('length'), and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nlength (integer): the target length for each text value.\n\nchar (string): the padding character. Defaults to a space (\" \"). Must be a single character.\n\nmode (string, optional): the padding direction. Possible values are \"right\" to pad on the right side (default), \"left\" to pad on the left side, and \"both\" to pad evenly on both sides (extra char goes to the right if uneven).",
        "example": "result = tt.text.pad(vals, length, char=' ', mode='right')"
    },
    "text.remove_whitespace": {
        "name": "remove_whitespace",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Remove all whitespace characters from each text value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.remove_whitespace(vals)"
    },
    "text.replace": {
        "name": "replace",
        "category": "text",
        "signature": "(self, vals, old_str, new_str)",
        "doc": "Replace a specified subtring or character ('old_str') from each text value of an input list ('vals') with a new specified substring or character ('new_str') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nold_str (string): the old substring or character to be replaced.\n\nnew_str (string): the new substring or character to replace the old.",
        "example": "result = tt.text.replace(vals, old_str, new_str)"
    },
    "text.reverse": {
        "name": "reverse",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Reverse each text value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.reverse(vals)"
    },
    "text.split": {
        "name": "split",
        "category": "text",
        "signature": "(self, vals, sep=None, maxsplit=-1)",
        "doc": "Split each text value in the input list ('vals') into a list of substrings, using the specified separator ('sep'), and return a nested list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nsep (string): the delimiter to split on. Defaults to None, which splits on any whitespace.\n\nmaxsplit (integer): the maximum number of splits to perform. Defaults to -1 (no limit).",
        "example": "result = tt.text.split(vals, sep=None, maxsplit=-1)"
    },
    "text.strip": {
        "name": "strip",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Remove all leading and trailing whitespace from each text value in the input list ('vals') and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.strip(vals)"
    },
    "text.to_list": {
        "name": "to_list",
        "category": "text",
        "signature": "(self, vals)",
        "doc": "Convert each string in the input list ('vals') into a list of characters and return a nested list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.",
        "example": "result = tt.text.to_list(vals)"
    },
    "text.trim": {
        "name": "trim",
        "category": "text",
        "signature": "(self, vals, trim_chars, mode='both')",
        "doc": "Trim the specified number of characters ('trim_chars') from text values in the input list ('vals') according to the chosen mode, and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\ntrim_chars (integer): the number of characters to remove.\n\nmode (string): the trimming mode. Possible values are \"start\" to trim characters from the beginning, \"end\" to trim characters from the end, and \"both\" to trim characters from both beginning and end.",
        "example": "result = tt.text.trim(vals, trim_chars, mode='both')"
    },
    "text.truncate": {
        "name": "truncate",
        "category": "text",
        "signature": "(self, vals, length, ellipsis=False)",
        "doc": "Truncate each text value in the input list ('vals') to the specified maximum length ('length'), and return a new list.\n\nParameters:\n\nvals (list): the list of values the operation will be performed on. The input list will not be altered by the operation.\n\nlength (integer): the maximum length for each text value. Must be non-negative.\n\nellipsis (Boolean): whether to append '...' if truncation occurs. Defaults to False.",
        "example": "result = tt.text.truncate(vals, length, ellipsis=False)"
    }
}